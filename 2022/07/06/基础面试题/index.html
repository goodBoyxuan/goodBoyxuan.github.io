<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.2.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://fastly.jsdelivr.net'>
  <link rel="preconnect" href="https://fastly.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>基础面试题 - Hexo</title>

  
    <meta name="description" content="Python 面试题   什么是python？使用python有什么好处  答：1、python非常简单，适合阅读。这种这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。 2、易学。python虽然是用c语言写的，但是它摈弃了c中非常复杂的指针，简化了python的语法。 3、可移植性——由于它的开源本质，Python已经被移植在许多平台上 4、、在计算机内部，Py">
<meta property="og:type" content="article">
<meta property="og:title" content="基础面试题">
<meta property="og:url" content="http://example.com/2022/07/06/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Python 面试题   什么是python？使用python有什么好处  答：1、python非常简单，适合阅读。这种这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。 2、易学。python虽然是用c语言写的，但是它摈弃了c中非常复杂的指针，简化了python的语法。 3、可移植性——由于它的开源本质，Python已经被移植在许多平台上 4、、在计算机内部，Py">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/32-1.png">
<meta property="og:image" content="http://example.com/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/32-2.png">
<meta property="og:image" content="http://example.com/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/vue-7.png">
<meta property="article:published_time" content="2022-07-06T06:40:34.000Z">
<meta property="article:modified_time" content="2022-08-08T08:38:29.424Z">
<meta property="article:author" content="知非">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/32-1.png">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="title" href="/"><div class="main">MengXuan</div></a></div>
<nav class="menu dis-select"></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"></div></div></div>


</div>


    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div><div id="post-meta">发布于&nbsp;<time datetime="2022-07-06T06:40:34.000Z">2022-07-06</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>基础面试题</span></h1>
<p><strong><strong>Python 面试题</strong></strong> </p>
<ol>
<li>什么是python？使用python有什么好处</li>
</ol>
<p>答：1、python非常简单，适合阅读。这种这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。</p>
<p>2、易学。python虽然是用c语言写的，但是它摈弃了c中非常复杂的指针，简化了python的语法。</p>
<p>3、可移植性——由于它的开源本质，Python已经被移植在许多平台上</p>
<p>4、、在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。</p>
<p>5、Python既支持面向过程的函数编程也支持面向对象的抽象编程。</p>
<p>6、可扩展性和可嵌入性。</p>
<p>7、丰富的库。</p>
<p>8、 Python确实是一种十分精彩又强大的语言。</p>
<p>9、规范的代码。</p>
<ol start="2">
<li>在Python中导入模块中的对象有哪几种方式</li>
</ol>
<p>答：import 模块名</p>
<p>from 模块名 import 功能名</p>
<p>from 模块名 import *</p>
<p>import 模块名 as 别名</p>
<p>from 模块名 import 功能名 as 别名</p>
<ol start="3">
<li>简述List 和tuple 区别</li>
</ol>
<p>1、list中是可变的，tuple不可变</p>
<p>　  所以tuple没有insert, pop,append方法</p>
<p>2、定义只有一个元素的tuple的时候，必须加逗号，否则不会被认为是tuple，而被识别为括号比如，a &#x3D; (1) 会被识别为数字1，(1,)这样才被识别为一个元组，只有一个元素，数字1</p>
<p>3、元组可以转列表，但不可以转字典</p>
<p>不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p>
<ol start="4">
<li>什么是模块？他有什么好处</li>
</ol>
<p>说的通俗点：模块就好比是工具包，要想使用这个工具包中的工具(就好比函数)，就需要导入这个模块</p>
<p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。</p>
<p>使用模块还可以避免函数名和变量名冲突。每个模块有独立的命名空间，因此相同名字的函数和变量完全可以分别存在不同的模块中，所以，我们自己在编写模块时，不必考虑名字会与其他模块冲突</p>
<ol start="5">
<li>简述try、except语句的用法</li>
</ol>
<p>try:</p>
<p>可能会出现异常的代码块</p>
<p>except 异常的类型:</p>
<p>  出现异常以后的处理语句</p>
<ol start="6">
<li>sort和sorted 方法的区别</li>
</ol>
<p>Python list内置sort()方法用来排序，也可以用python内置的全局sorted()方法来对可迭代的序列排序生成新的序列。</p>
<p>list.sort()和sorted()都接受一个参数reverse（True or False）来表示升序或降序排序</p>
<ol start="7">
<li>如何理解面向对象中的封装 继承 和多态</li>
</ol>
<p>封装：这是定义类的准则，根据对象的特点，将行为和属性抽象出来，封装到一个类中。</p>
<p>继承：这是设计类的技巧。父类与子类，主要体现在代码的重用，不需要大量的编写重复代码。</p>
<p>多态：不同的子类调用相同的父类方法，产生不同的执行结果，可以增加代码的外部灵活度。多态是以继承和重写父类方法为前提的，它是一种调用方法的技巧，不会影响到类的内部设计。</p>
<ol start="8">
<li>列举常见的异常 及出现的场景</li>
</ol>
<p>SystemExit　　　　　　　　 　　　解释器请求退出</p>
<p>AttributeError 　　　　　　　　　　对象没有这个属性</p>
<p>NameError 　　　　　　　　　　未声明&#x2F;初始化对象 (没有属性)</p>
<p>IndexError 　　　　　　　　　　序列中没有此索引(index)</p>
<p>KeyError　　　　　　　　　　　　 映射中没有这个键</p>
<p>ImportError　　　　　　　　　　 导入模块&#x2F;对象失败</p>
<p>TypeError　　　　　　　　　　　　 对类型无效的操作</p>
<p>ValueError 　　　　　　　　　　　　传入无效的参数</p>
<ol start="9">
<li><p>字典、列表、集合有哪些的方法</p>
</li>
<li><p>双等（&#x3D;&#x3D;） 和 is 有什么区别</p>
</li>
</ol>
<p> &#x3D;&#x3D;比较操作符：用来比较两个对象是否相等，value做为判断因素；</p>
<p> is同一性运算符：比较判断两个对象是否相同，id做为判断因素。</p>
<ol start="11">
<li>python都有哪些自带的数据类型</li>
</ol>
<p>Python主要内置类型包括数值、序列、映射、类、实例和异常等。<br>数值类型：全局中只有一个（Python在解释器启动的时候，Python会用None类型生成一个None的对象），包括int类型、float类型、complex类型、bool类型。<br>迭代类型：在Python中，迭代类型可以使用循环来进行遍历。<br>序列类型：list（是可变序列，通常用于存放同类项目的集合）、tuple（是不可变序列，通常用于储存异构数据的多项集）、str（在Python中处理文本数据是使用str对象，也称为字符串。字符串是由Unicode码位构成的不可变序列。）、array、range（表示不可变的数字序列，通常用于在for循环中循环指定的次数）、bytes（由单个字节构成的不可变序列）、bytearray（bytes对象的可变对应物）、memoryvie（二进制序列）<br>映射类型：映射对象将具有hash的值映射到任意对象。映射是可变的对象。目前只有一种标准映射，即dictionary。字典的键几乎是任意值，也就是说，包含列表、字典或其他可变类型的值。<br>集合类型：作为一种无序的多项集，集合并不记录元素位置或插入顺序。相应地，集合不支持索引、切片或其他序列类的操作。目前Python有两种内置集合类型：set和frozenset。</p>
<ol start="12">
<li>可变数据类型和不可变类型分别包括那些</li>
</ol>
<p><strong><strong>不可变数据类型</strong><strong><strong><strong>：</strong></strong></strong><strong>整型</strong><strong><strong><strong>，</strong></strong></strong><strong>字符串</strong><strong><strong><strong>，</strong></strong></strong><strong>元组</strong></strong></p>
<p><strong><strong>可变数据类型</strong><strong><strong><strong>：</strong></strong></strong><strong>集合</strong><strong><strong><strong>，</strong></strong></strong><strong>列表</strong><strong><strong><strong>，</strong></strong></strong><strong>字典</strong></strong></p>
<ol start="13">
<li>python 有哪些常见的运算符</li>
</ol>
<p>算数运算符+-*&#x2F;%</p>
<p>逻辑运算符：and or not</p>
<p>成员运算符:in  not in</p>
<p>身份运算符:is  is not</p>
<ol start="14">
<li>如何删除一个列表中重复的元素</li>
</ol>
<p>直接遍历列表删除</p>
<p>通过遍历索引删除</p>
<p>通过遍历创建的切片来删除原列表</p>
<p>通过递归函数删除</p>
<p>set()</p>
<ol start="15">
<li>python中pass语句作用是什么</li>
</ol>
<p>在编写代码时只写框架思路，具体实现还未编写就可以用 pass 进行占位，使程序不报错，不会进行任何操作。</p>
<ol start="16">
<li>range()函数的作用</li>
</ol>
<p>range()函数是一个可迭代对象（类型是对象）</p>
<p>range(start,stop[,step])</p>
<p>start：计数从start开始，默认为0</p>
<p>stop:计数到stop结束，但不包括stop</p>
<p>step：步长，默认为1，range(10),等价于range(0,10,1)</p>
<ol start="17">
<li>什么是闭包？闭包的特性</li>
</ol>
<p>闭包是由函数及其相关的引用环境组合而成的实体(即：闭包&#x3D;函数块+引用环境)。</p>
<p>如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包</p>
<ol start="18">
<li>python的装饰器是什么</li>
</ol>
<p>它们是修改其他函数的功能的函数。有助于让我们的代码更简短；装饰器传入的参数就是一个函数，然后通过实现各种功能来对这个函数的功能进行增强。</p>
<ol start="19">
<li>python深拷贝、浅拷贝和赋值之间有什么区别</li>
</ol>
<p>Python中对象的赋值都是进行对象引用（内存地址）传递</p>
<p>使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用.</p>
<p>如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝</p>
<p>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有被拷贝一说</p>
<p>如果元祖变量只包含原子类型对象，则不能深拷贝</p>
<ol start="20">
<li>.面向对象有哪些特性</li>
</ol>
<p>1）继承是从已有类得到继承信息创建新类的过程。提供继承信息的类为父类；得到继承信息的类为子类。</p>
<p>2）封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。在类中编写的方法就是对实现细节的封装；编写一个类就是对数据和数据操作的封装。</p>
<p>3）多态性是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。方法重载实现的是编译时的多态性，而方法重写实现的是运行时的多态性，实现多态要做两件事：1. 方法重写；2. 对象造型。</p>
<p>4）抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。</p>
<ol start="21">
<li>什么是继承？什么是多态</li>
</ol>
<p>多态是：一个对象可以被多个其他对象动态调用<br>继承是：一个子类可以继承父类的属性和方法</p>
<ol start="22">
<li>如何获取当前时间并格式化输出</li>
</ol>
<p>1、导入time模块</p>
<p>2、打印时间戳-time.time()</p>
<p>3、格式化时间戳为本地的时间-time.localtime()</p>
<p>print(time.strftime(‘%Y-%m-%d %H:%M:%S’,time.localtime(time.time())))</p>
<ol start="23">
<li>普通函数和lambda函数有什么异同点</li>
</ol>
<p>它们是相同的类型,因此它们以相同的方式处理。</p>
<p>唯一的区别是（a）lambda的主体只能由一个表达式组成，其结果是从创建的函数返回的，（b）alambda表达式是一个计算为函数对象的表达式，而adef语句没有值，并创建一个函数对象并将其绑定到一个名称。</p>
<ol start="24">
<li>什么是列表生成式</li>
</ol>
<p>用来创建列表 (list) 的表达式就是列表生成式，也被称为列表推导式</p>
<ol start="25">
<li><p>python装饰器的作用</p>
</li>
<li><p>python都有哪些内置函数</p>
</li>
<li><p>abs() 2. all() chr() dict() eval() filter() format() input() len() print()  reversed() slice()</p>
</li>
<li><p>python的生成器是什么</p>
</li>
</ol>
<p>Python 中还有一种函数，用关键字 yield 来返回值，这种函数叫生成器函数，函数被调用时会返回一个生成器对象，生成器本质上还是一个迭代器</p>
<ol start="28">
<li>python的迭代器是什么</li>
</ol>
<p>迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<ol start="29">
<li>什么是类方法、静态方法和实例方法</li>
</ol>
<p>其中类方法需要使用@classmethod装饰器<br>静态方法需要使用@staticmethod装饰器</p>
<p>类方法参数cls，实例方法参数self，静态方法相当于寄存在这个类中的方法。</p>
<ol start="30">
<li>读写文件常用的方法有哪些</li>
</ol>
<table>
<thead>
<tr>
<th>f.read()</th>
<th>读取文件中所有内容</th>
</tr>
</thead>
<tbody><tr>
<td>f.readline()</td>
<td>读取第一行的内容</td>
</tr>
<tr>
<td>f.readlines()</td>
<td>读取文件里面所有内容，把每行的内容放到一个list里面</td>
</tr>
</tbody></table>
<p>with open ： 用完后自动关闭文件，省去了手动添加f.close()功能</p>
<ol start="31">
<li>Linux 开机启动过程</li>
</ol>
<p>· 加载BIOS(Basic Input Output System)：BIOS是系统启动时加载的第一个软件。</p>
<p>o 启动上电自检POST(Power-On-Self-Test)，负责完成对CPU、主板、内存、软硬盘子系统、显示子系统（包括显示缓存）、串并行接口、键盘、CD-ROM光驱等的检测，主要检查硬件的好坏。</p>
<p>o 对外部设备进行初始化，读取BIOS参数，并和实际的硬件进行比较，如果不符合，会影响系统启动。</p>
<p>o 查找MBR(Master Boot Record,主引导分区)。如果未找到，会提示找不到硬盘。</p>
<p>· 读取主引导分区(MBR):拷贝启动引导代码BootLoader</p>
<p>· 启动引导代码(bootloader):当我们的硬盘上有多个操作系统时，可以用来选择进入到哪个操作系统。</p>
<p>· 加载内核，进入操作系统：运行第一个程序 : &#x2F;sbin&#x2F;init</p>
<p>o sbin&#x2F;init 会读取相关的配置文件，来确定系统的运行级别。</p>
<p>§ 0： 关机</p>
<p>§ 1 ： 单用户模式</p>
<p>§ 2 ： 无网络支持的多用户模式</p>
<p>§ 3 ： 有网络支持的多用户模式</p>
<p>§ 4 ： 保留，未使用</p>
<p>§ 5 ： 有网络支持，且有图形化界面的多用户模式</p>
<p>§ 6 ： 重启</p>
<p>§ 切换运行级别： init 级别</p>
<p>o 根据对应的运行级别，查找对应的脚本文件。例如，运行5级别，查找 &#x2F;etc&#x2F;rc5.d目录，启动该目录下的相关服务。</p>
<p>§ 这些文件夹下的init脚本都有一些特别的名字，命名都以S（start）、K（kill）或D（disable）开头，后面跟一个数字。当init进入一个运行等级的时候，它会按照数字顺序运行所有以K开头的脚本并传入stop参数，除非对应的init脚本在前一个运行等级中没有启动。然后init按照数字顺序运行所有以S开头的脚本并传入start参数。任何以D开头的init脚本都会被忽略—这让你可以在指定的运行等级禁止一个脚本，或者你也可以仅仅移除全部符号链接。</p>
<p>o 解析用户自定义的启动脚本：&#x2F;etc&#x2F;rc.local（如果存在的话）</p>
<p>o 进入用户界面。</p>
<ol start="32">
<li>Linux 的目录结构是怎样的</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/32-1.png" alt="img"> </p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/32-2.png" alt="img"> </p>
<ol start="33">
<li>什么是硬链接和软链接</li>
</ol>
<p>软链接：ln -s 源文件 目标文件<br>硬链接：ln 源文件 目标文件<br>源文件：即你要对谁建立链接</p>
<p>区别: 软链接文件的大小和创建时间和源文件不同。软链接文件只是维持了从软链接到源文件的指向关系（从jys.soft-&gt;jys可以看出），不是源文件的内容，大小不一样容易理解。<br>硬链接文件和源文件的大小和创建时间一样。硬链接文件的内容和源文件的内容一模一样，相当于copy了一份。</p>
<ol start="34">
<li>如何查看系统都开启了哪些端口</li>
</ol>
<p>netstat:用来监听网络连接状态。</p>
<p>ps</p>
<p>作用：查看进程信息</p>
<p>使用：</p>
<p>ps -ef</p>
<p>ps aux</p>
<p>说明：经常在查询进程号的时候结合grep进行过滤</p>
<p>pstree</p>
<p>作用：使用树形结构查看进程信息。</p>
<p>kill</p>
<p>作用：杀死进程</p>
<p>示例：kill -9 PID</p>
<p>说明：强制杀死指定进程</p>
<ol start="35">
<li>使用free查看内存使用情况时，哪个数值表示真正可用的内存量</li>
</ol>
<p>· Total（全部） : 1026740</p>
<p>· Used（已用） : 843396</p>
<p>· Free（可用） : 183344</p>
<p>· Shared（共享） : 0</p>
<p>· Buffers（块设备缓存区） : 52704</p>
<p>· Cached（文件缓存） : 376384</p>
<p><strong><strong>Django面试题</strong></strong></p>
<ol>
<li>什么是http协议</li>
</ol>
<p>http(Hypertext transfer protocol)超文本传输协议，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。也就是说，http协议规定了超文本传输所要遵守的规则。</p>
<ol start="2">
<li>http请求报文组成</li>
</ol>
<p>1）请求方法URI协议&#x2F;版本 </p>
<p>2）请求头(Request Header) </p>
<p>3）请求正文</p>
<ol start="3">
<li>http响应报文组成</li>
</ol>
<p>1）状态行</p>
<p>2）响应头</p>
<p>3）响应正文</p>
<ol start="4">
<li>https协议和http的区别</li>
</ol>
<p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p>　　为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<ol start="5">
<li>说一下对对端口的理解</li>
</ol>
<p>可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指 计算机内部 或 交换机 路由器内的端口，不可见。例如计算机中的80端口、21端口、23端口等。物理端口又称为接口，是可见端口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口都属于物理端口。</p>
<ol start="6">
<li>说一下对django 的认识</li>
</ol>
<p>#1.Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。</p>
<p>#2.Django内置的ORM跟框架内的其他模块耦合程度高。</p>
<p>#应用程序必须使用Django内置的ORM，否则就不能享受到框架内提供的种种基于其ORM的便利；</p>
<p>#理论上可以切换掉其ORM模块，但这就相当于要把装修完毕的房子拆除重新装修，倒不如一开始就去毛胚房做全新的装修。</p>
<p>#3.Django的卖点是超高的开发效率，其性能扩展有限；采用Django的项目，在流量达到一定规模后，都需要对其进行重构，才能满足性能的要求。</p>
<p>#4.Django适用的是中小型的网站，或者是作为大型网站快速实现产品雏形的工具。</p>
<p>#5.Django模板的设计哲学是彻底的将代码、样式分离； Django从根本上杜绝在模板中进行编码、处理数据的可能。</p>
<ol start="7">
<li>什么是mtv</li>
</ol>
<p>Model(模型)： 负责业务对象与数据库的对象(ORM)。</p>
<p>Template(模板)：负责如何把页面展示给用户。</p>
<p>View(视图)：负责业务逻辑，并在适当的时候调用Model和Template。</p>
<ol start="8">
<li>什么是wsgi</li>
</ol>
<p>WSGI是一套接口标准协议&#x2F;规范；</p>
<p>通信（作用）区间是Web服务器和Python Web应用程序之间；</p>
<p>目的是制定标准，以保证不同Web服务器可以和不同的Python程序之间相互通信</p>
<ol start="9">
<li>django请求的生命周期</li>
</ol>
<p>Django的请求生命周期是指当用户在浏览器上输入url到用户看到网页的这个时间段内,Django后台所发生的事情</p>
<ol>
<li><p>当用户在浏览器中输入url时,浏览器会生成请求头和请求体发给服务端 请求头和请求体中会包含浏览器的动作(action),这个动作通常为get或者post,体现在url之中.</p>
</li>
<li><p>url经过Django中的wsgi,再经过Django的中间件,最后url到过路由映射表,在路由中一条一条进行匹配, 一旦其中一条匹配成功就执行对应的视图函数,后面的路由就不再继续匹配了. </p>
</li>
<li><p>视图函数根据客户端的请求查询相应的数据.返回给Django,然后Django把客户端想要的数据做为一个字符串返回给客户端. </p>
</li>
<li><p>客户端浏览器接收到返回的数据,经过渲染后显示给用户.</p>
</li>
<li><p>简述什么是FBV和CBV</p>
</li>
</ol>
<p>一个url对应一个视图函数,这个模式叫做FBV(Function Base Views)</p>
<p>另外一种模式叫做CBV(Class Base views),即一个url对应一个类</p>
<ol start="11">
<li>什么是orm</li>
</ol>
<p>对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。<br>简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。<br>ORM在业务逻辑层和数据库层之间充当了桥梁的作用。</p>
<ol start="12">
<li>Orm和原生slq的优缺点</li>
</ol>
<p>作用：帮助我们封装一下对数据库的操作，避免了我们写不太好维护的SQL的代码<br>优点：比较好维护，不用写那些复杂的sql语句<br>缺点：失去SQL的灵活性，并且越是通用的ORM框架，对性能的消耗就越大</p>
<ol start="13">
<li><p>列举django orm 中常用的方法</p>
</li>
<li><p>models.Book.objects.all()  # 获取到所有的书籍对象,结果是对象列表</p>
</li>
<li><p>models.Book.objects.get(条件)  # 获取符合条件的对象</p>
</li>
<li><p>models.Book.objects.filter(条件)  # 筛选所有符合条件的,结果是对象列表</p>
</li>
<li><p>models.Book.objects.all().values( )  # 字典列表,[ {id:1,name:20} , {id:2,name:18} ]</p>
</li>
</ol>
<p>​    values(‘id’)括号内不指定时显示全部,如指定则只显示指定的,[ {id:1} , {id:2,} ]</p>
<pre><code>6. models.Book.objects.all().values_list( )  # 元组列表,[ (1,20) , (2,18) ]同上,指定时显示指定内容
</code></pre>
<ol start="7">
<li>models.Book.objects.all().count()  # 计数,可统计结果个数,如对Queryset内元素数进行统计.</li>
</ol>
<pre><code>8. models.Book.objects.all().first()  # 获取结果中的第一条,即使前面结果列表为空,也不会报错

9. models.Book.objects.filter().last()  # 获取结果中的最后一条
</code></pre>
<p>  13.models.Book.objects.filter().exists()  # 判断Queryset列表是否有东西,结果为True或False; </p>
<ol start="14">
<li>class Meta中的元信息字段有哪些</li>
</ol>
<p>Abstract  app_label   db_table   default_related_name   managed</p>
<ol start="15">
<li>Orm 操作values和values_list的区别</li>
</ol>
<p>values()的结果得到的是一个字典形式的查询集QuerySet，查询集是一个可迭代对象</p>
<p>values_list()返回的是列表元组</p>
<ol start="16">
<li>什么是Cookie、如何获取、设置Cookie</li>
</ol>
<p>cookie：存储数据，当用户访问了某个网站（网页）的时候，我们就通过cookie来向访问者电脑上存储数据</p>
<p>设置： response.set_cookie(‘my_cookie’,’cookie value’)</p>
<p>获取：value &#x3D; request.COOKIES[“cookie_key”]</p>
<ol start="17">
<li>cookie和session的区别</li>
</ol>
<p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上.</p>
<p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</p>
<p>3、设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。<br>4、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。<br>5、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)</p>
<p>18.django的Model中的ForeignKey字段中的on_delete参数有什么作用</p>
<p>on_delete有6个可选值，分别是：</p>
<p>CASCADE    删除级联，当父表的记录删除时，子表中与其相关联的记录也会删除。即：当一个老师被删除时，关联该老师的学生也会被删除。</p>
<p>PROTECT    子表记录所关联的父表记录被删除时，会报ProtectedError异常。即：当一个学生所关联的老师被删除时，会报ProtectedError异常。</p>
<p>SET_NULL    子表记录所关联的父表记录被删除时，将子表记录中的关联字段设为NULL，注意：需要允许数据表的该字段为NULL。</p>
<p>SET_DEFAULT    子表记录所关联的父表记录被删除时，将子表记录中的关联字段设为一个给定的默认值。</p>
<p>DO_NOTHING    子表记录所关联的父表记录被删除时，什么也不做。</p>
<p>“SET”()    设置为一个传递给“SET”()的值或者一个回调函数的返回值，该参数用得相对较少。</p>
<ol start="19">
<li>django中csrf的实现机制</li>
</ol>
<p>django为用户实现防止跨站请求伪造的功能，通过中间件 “django.middleware.csrf.CsrfViewMiddleware” 来完成。而对于django中设置防跨站请求伪造功能有分为全局和局部。</p>
<p>1）启用中间件<br>2）post请求<br>3）验证码<br>4）表单中添加“{”% csrf_token%“}”标签</p>
<ol start="20">
<li>命令makemigrations和migrate的区别</li>
</ol>
<p>makemigrations：将模型的更改生成迁移脚本文件。</p>
<p>migrate：将新生成的迁移脚本，映射到数据库中，创建新的表或者修改表的结构。</p>
<ol start="21">
<li>视图函数中，接收的请求对象常用方法和属性有哪些</li>
</ol>
<p>COOKIES,FILES,POST,GET,method</p>
<ol start="22">
<li>HTTP响应常见状态码分类</li>
</ol>
<p>200 OK：表示从客户端发送给服务器的请求被正常处理并返回；</p>
<p>400 Bad Request：表示请求报文中存在语法错误；</p>
<p>401 Unauthorized：未经许可，需要通过HTTP认证；</p>
<p>403 Forbidden：服务器拒绝该次访问（访问权限出现问题）</p>
<p>404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</p>
<p>500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；</p>
<ol start="23">
<li>在Django中，服务端给客户端响应信息有几种方式？分别是什么</li>
</ol>
<p>HTTPresponse，<br>jsonresponse,<br>redirect</p>
<ol start="24">
<li>路由匹配原则是什么</li>
</ol>
<p>path不支持正则匹配</p>
<p>re_path支持正则匹配</p>
<p>include引用头文件</p>
<ol start="25">
<li>解决跨域的常用方式是什么</li>
</ol>
<p>pip install django-cors-headers</p>
<p>在项目的settings.py文件配置</p>
<p>注册应用</p>
<p>INSTALLED_APPS  &#x3D;  [ </p>
<p>  …</p>
<p>  ‘corsheaders’ ，</p>
<p>  …</p>
<p>]</p>
<p>注册中间件</p>
<p>MIDDLEWARE  &#x3D;  [</p>
<p>  … </p>
<p>  ‘corsheaders.middleware.CorsMiddleware’ ,  # 注册中间件</p>
<p>  ‘django.middleware.common.CommonMiddleware’ ，</p>
<p>  … </p>
<p>]</p>
<p>设置允许的来源</p>
<h1 id="允许全部来源"><a href="#允许全部来源" class="headerlink" title="允许全部来源"></a>允许全部来源</h1><p>CORS_ORIGIN_ALLOW_ALL  &#x3D; True  # 如果为True，将不使用白名单，并且将接受所有来源。默认为False。</p>
<h1 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h1><p>CORS_ORIGIN_WHITELIST  &#x3D;  [</p>
<p>  “<a target="_blank" rel="noopener" href="https://example.com&quot;/">https://example.com&quot;</a>,</p>
<p>  “<a target="_blank" rel="noopener" href="https://sub.example.com&quot;/">https://sub.example.com&quot;</a>,</p>
<p>  “http：&#x2F;&#x2F; localhost：8080”,</p>
<p>  “<a href="http://127.0.0.1:9000&quot;">http://127.0.0.1:9000&quot;</a></p>
<p>]</p>
<ol start="26">
<li>get请求和post请求的区别</li>
</ol>
<p>POST和GET是HTTP协议定义的与服务器交互的方法。GET一般用于获取&#x2F;查询资源信息，而POST一般用于更新资源信息</p>
<p>1.post是取web页面中提交的值</p>
<p>2.get是从数据库中取值</p>
<p>GET是通过URL传给服务器的,POST是通过HTTP头传给服务器的，post的数据是不跟在请求的url后，而是在http头中，get是在url中</p>
<ol start="27">
<li>QueryDict和dict区别</li>
</ol>
<p>Querydict ：可以一键对应多个值</p>
<p>dict ：只能一键对应一个值</p>
<ol start="28">
<li>列举Http请求中常见的请求方式</li>
</ol>
<p>POST,GET,PUT,DELETE,TRACCE</p>
<ol start="29">
<li>谈谈你对restful规范的认识</li>
</ol>
<p>（1） 每一个URL代表一种资源<br>（2） 客户端与服务器之间，传递这种资源的某种表现层<br>（3） 客户端通过 4 个HTTP动词，对服务器端资源进行操作，实现“表现层状态转化”</p>
<ol start="30">
<li>Django 本身提供了 runserver，为什么不能用来部署</li>
</ol>
<p>runserver 方法是调试 Django 时经常用到的运行方式，它使用 Django 自带的</p>
<p><strong><strong>Js面试题</strong></strong></p>
<ol>
<li>说一下从输入URL到页面加载完中间发生了什么</li>
</ol>
<p>1、DNS域名解析 2、发起TCP连接（三次握手）  3、发送HTTP请求，接受HTTP响应     4、断开TCP连接（四次挥手）  5、浏览器解析HTML代码，请求js，css等资源，最后进行页面渲染，呈现给用户</p>
<ol start="2">
<li>说一下js数据类型有哪些？</li>
</ol>
<p>1.字符串 string</p>
<p>2.数字    Number</p>
<p>3.布尔    Boolean</p>
<p>4.空      null</p>
<p>5.未定义的 undefined</p>
<p>6.对象    object</p>
<p> 对象包括（array数组   json  function 函数 日期 数字对象等）</p>
<ol start="3">
<li>解释 JavaScript 中“undefined”和“not defined”之间的区别</li>
</ol>
<p>undefined是javascript语言中定义的五个原始类中的一个，换句话说，undefined并不是程序报错，而是程序允许的一个值。<br>not defined是javascript在运行我们的javascript代码时，遇到没有定义就用来运算的变量时爆出来的错误。</p>
<ol start="4">
<li><p>请描述值类型(基本数据类型)和引用类型的区别</p>
</li>
<li><p>值类型：String(字符串)，Number（数字），Boolean(布尔类型),Undefinde<br>2.引用类型：Array(数组)，Object(对象)，Function(函数)</p>
</li>
</ol>
<p>储存方式不一样：值类型是栈存储，引用类型是堆存储</p>
<p>变量赋值：基本数据类型是直接把值赋给变量。而引用类型是，把值的地址复制给新变量，通过地址再找到内容。</p>
<ol start="5">
<li>说一下JS作用域</li>
</ol>
<p>作用域就是变量与函数的可访问范围，即作用域控制着函数与变量的可见性和生命周期</p>
<p>1.全局作用域</p>
<p>任何地方都能访问到的对象拥有全局作用域</p>
<p>1.1.函数外面定义的变量拥有全局作用域，全局变量拥有全局作用域，网页中所有脚本和函数均可使用。全局变量在页面关闭后销毁</p>
<p>1.2.未定义直接赋值的变量自动声明为全局变量拥有全局作用域</p>
<p>1.3.window对象的属性拥有全局作用域</p>
<p>HTML中，全局变量是window对象，所有数据变量都属于window对象</p>
<p>2.局部作用域</p>
<p>局部作用域一般只在固定的代码片段内能访问到，最常见的例如函数内部，所以也称为函数作用域</p>
<p>变量在函数内声明，变量为局部作用域</p>
<p>局部变量：只能在函数内访问</p>
<p>ES6的块级作用域</p>
<p>ES6引入了块级作用域，明确允许在块级作用域中申明函数，let和const命令都涉及块级作用域</p>
<p>块级作用域允许声明函数只在使用大括号的情况下成立，如果未使用大括号报错</p>
<ol start="6">
<li>什么是 JavaScript 中的提升操作</li>
</ol>
<p>:用var声明的变量提升,其只是变量提升了，而没有进行赋值的提升</p>
<ol start="7">
<li>什么是JavaScript原型，原型链 ? 有什么特点？</li>
</ol>
<p>JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象，当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p>
<p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法</p>
<p>在对象实例和它的构造器之间建立一个链接（它是__proto____属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法</p>
<ol start="8">
<li>如何判断数组</li>
</ol>
<p>通过es6 Array.isArrray()做判断</p>
<p>通过instanceof做判断</p>
<ol start="9">
<li>说一下JS数组常用方法</li>
</ol>
<p>Array.map()  Array.forEach()  Array.filter()  Array.every()  Array.some()  Array.push()  Array.pop()  Array.shift()  Array.unshift()</p>
<ol start="10">
<li>说一下字符串操作的常用方法</li>
</ol>
<p>slice方法、substring方法</p>
<ol start="11">
<li><p>说一下JS原生常用dom操作方法</p>
</li>
<li><p>浏览器是如何渲染页面的</p>
</li>
</ol>
<p>1.根据html文件构建DOM树和CSSOM树。构建DOM树期间，如果遇到JS，阻塞DOM树及CSSOM树的构建，优先加载JS文件，加载完毕，再继续构建DOM树及CSSOM树。</p>
<p>2.构建渲染树（Render Tree）。</p>
<p>3.页面的重绘（repaint）与重排（reflow，也有称回流）。页面渲染完成后，若JS操作了DOM节点，根据JS对DOM操作动作的大小，浏览器对页面进行重绘或是重排。</p>
<ol start="13">
<li>简述同步与异步的区别</li>
</ol>
<p>同步就相当于是 当客户端发送请求给服务端，在等待服务端响应的请求时，客户端不做其他的事情。当服务端做完了才返回到客户端。这样的话客户端需要一直等待。用户使用起来会有不友好。</p>
<p>异步就是，当客户端发送给服务端请求时，在等待服务端响应的时候，客户端可以做其他的事情，这样节约了时间，提高了效率。</p>
<ol start="14">
<li>什么是promise</li>
</ol>
<p>一.Promise是异步编程的一种解决方案，它是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>
<p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同</p>
<p>样的方法进行处理。promise对象是一个构造函数，用来生成Promise实例；</p>
<p>二.promise的两个特点  对象状态不受外界影响 &amp;&amp; 一旦状态改变，就不会再变，任何时候都可以得到结果（pending状态–&gt;fulfilled || pending–&gt;rejected）</p>
<ol start="15">
<li><p>async&#x2F;await是什么</p>
</li>
<li><p>Async—声明⼀个异步函数(async function someName(){…})</p>
</li>
<li><p>⾃动将常规函数转换成Promise，返回值也是⼀个Promise对象</p>
</li>
<li><p>只有async函数内部的异步操作执⾏完，才会执⾏then⽅法指定的回调函数</p>
</li>
<li><p>异步函数内部可以使⽤await</p>
</li>
<li><p>Await—暂停异步的功能执⾏(var result &#x3D; await someAsyncCall();)</p>
</li>
<li><p>放置在Promise调⽤之前，await强制其他代码等待，直到Promise完成并返回结果</p>
</li>
<li><p>只能与Promise⼀起使⽤，不适⽤与回调</p>
</li>
<li><p>只能在async函数内部使⽤</p>
</li>
<li><p>箭头函数的this指向哪里</p>
</li>
</ol>
<p>1.在全局环境下，this 始终指向全局对象（window）</p>
<p>2.对象内部方法的this指向调用这些方法的对象，函数的定义位置不影响其this指向，this指向只和调用函数的对象有关。</p>
<p>多层嵌套的对象，内部方法的this指向离被调用函数最近的对象（window也是对象，其内部对象调用方法的this指向内部对象， 而非window）。</p>
<p>3.构造函数中的this与被创建的新对象绑定。</p>
<ol start="17">
<li>null与undefined的区别是什么</li>
</ol>
<p>null表示”没有对象”，即该处不应该有值。</p>
<p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>
<ol start="18">
<li>说一下 call,apply,bind区别</li>
</ol>
<p>　1）apply，call和bind都是 用来改变this的指向</p>
<p>　2）apply和call会让当前函数立即执行，而bind会返回一个函数，后续需要的时候再调用执行</p>
<ol start="19">
<li>说一下你对JS面向对象的理解</li>
</ol>
<p>但JS中对象与纯面向对象语言中的对象是不同的，ECMA标准定义JS中对象：无序属性的集合，其属性可以包含基本值、对象或者函数。可以简单理解为JS的对象是一组无序的值，其中的属性或方法都有一个名字，根据这个名字可以访问相映射的值（值可以是基本值&#x2F;对象&#x2F;方法）。</p>
<ol start="20">
<li>说一下ES6新增特性</li>
</ol>
<p>第七种数据类型Symbol</p>
<p>Symbol用法很强大普遍，es5私有api中已经有很多的使用，例如：常用的String.prototype.split()。</p>
<p>Symbol创建的值唯一。</p>
<p>替代传统的常量定义保证唯一并且不被串改将是非常友好的。</p>
<p>定义私有属性将会非常方便。</p>
<p>1、let关键字，用来代替 var的关键字，特点： 1、变量不允许被重复定义 2、不会进行变量声明提升 3、保留块级作用域中i的</p>
<p>2、const定义常量，特点：1、常量值不允许被改变 2、不会进行变量声明提升</p>
<p>字符串模板&#96;&#96;</p>
<ol start="21">
<li>谈谈你对原型链的理解</li>
</ol>
<p>访问一个对象属性时，先在自身属性中查找，找到返回</p>
<p>如果没有，再沿着__proto__这条链向上查找，找到返回</p>
<p>如果最终没有找到，返回undefined</p>
<ol start="22">
<li>如何阻止事件冒泡</li>
</ol>
<p>Event.stoppropagation()</p>
<ol start="23">
<li>如何阻止默认事件</li>
</ol>
<p>event.preventDefault();</p>
<ol start="24">
<li>什么是ajax？ajax作用是什么</li>
</ol>
<p>AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。</p>
<p>通过 AJAX  可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据。</p>
<p>AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。</p>
<p>可以无需刷新页面而与服务器端进行通信。</p>
<p>允许你根据用户事件来更新部分页面内容。</p>
<ol start="25">
<li>原生js ajax请求有几个步骤？分别是什么</li>
</ol>
<p>a.创建 XMLHttpRequest对象</p>
<p>var ajax &#x3D; new XMLHttpRequest()</p>
<p>b.规定请求的类型、URL 以及是否异步处理请求</p>
<p>ajax.open(‘GET’,url,true)</p>
<p>c.发送信息至服务器时内容编码类型</p>
<p>ajax.setRequestHeader(“Content-type”,“application&#x2F;x-www-form-urlencoded”)</p>
<p>d.发送请求</p>
<p>ajax.send(null);</p>
<p>e.接受服务器响应数据</p>
<p>ajax.onreadystatechange &#x3D; function () {if (obj.readyState &#x3D;&#x3D; 4 &amp;&amp; (obj.status &#x3D;&#x3D; 200 || obj.status &#x3D;&#x3D; 304)){}”}</p>
<ol start="26">
<li>json字符串转换集json对象、json对象转换json字符串</li>
</ol>
<p>JSON.parse()方法,   JSON.stringify()方法</p>
<ol start="27">
<li>什么是JSON</li>
</ol>
<p>一种轻量级的数据交互格式。json就是一种在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互。</p>
<ol start="28">
<li>什么情况造成跨域</li>
</ol>
<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<p>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？</p>
<p>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p>
<p>由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>
<ol start="29">
<li>http常见状态码有哪些</li>
</ol>
<p>200 OK：表示从客户端发送给服务器的请求被正常处理并返回；</p>
<p>400 Bad Request：表示请求报文中存在语法错误；</p>
<p>401 Unauthorized：未经许可，需要通过HTTP认证；</p>
<p>403 Forbidden：服务器拒绝该次访问（访问权限出现问题）</p>
<p>404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</p>
<p>500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；</p>
<ol start="30">
<li>说一下同源策略</li>
</ol>
<p><strong><strong>Vue面试题</strong></strong></p>
<ol>
<li>MVC、MVP与MVVM模式</li>
</ol>
<p>MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式： [1]</p>
<p>Model（模型）表示应用程序核心（如数据库）。</p>
<p>View（视图）显示效果（HTML页面）。</p>
<p>Controller（控制器）处理输入（业务逻辑）。</p>
<p>MVP 是从经典的模式MVC演变而来，它们的基本思想有相通的地方Controller&#x2F;Presenter负责逻辑的处理，Model提供数据，View负责显示。</p>
<p>MVVM是Model-View-ViewModel的简写</p>
<p>· 模型</p>
<p>·  模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。</p>
<p>· 视图</p>
<p>·  就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。</p>
<p>· 视图模型</p>
<p>·  视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。</p>
<ol start="2">
<li>vue.js的两个核心是什么</li>
</ol>
<p>数据驱动：ViewModel，保证数据和视图的一致性。</p>
<p>组件系统：应用类UI可以看作全部是由组件树构成的。</p>
<ol start="3">
<li>什么是虚拟dom</li>
</ol>
<p>virtual DOM 虚拟DOM，用普通js对象来描述DOM结构，因为不是真实DOM，所以称之为虚拟DOM。这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示 dom 树及其层级结构，那么每次 dom 的更改就变成了对 js 对象的属性的增删改查，这样一来查找 js 对象的属性变化要比查询 dom 树的性能开销小。</p>
<ol start="4">
<li>Real DOM与 Virtual DOM 的区别</li>
</ol>
<p>虚拟DOM不会进行排版与重绘操作，而真实DOM会频繁重排与重绘</p>
<p>虚拟DOM的总损耗是“虚拟DOM增删改+真实DOM差异增删改+排版与重绘”，真实DOM的总损耗是“真实DOM完全增删改+排版与重绘”</p>
<ol start="5">
<li><p>什么是diff算法</p>
</li>
<li><p>请详细说下你对vue生命周期的理解</p>
</li>
</ol>
<p>Vue 实例有一个完整的生命周期，也就是从 开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>
<ol start="7">
<li>第一次页面加载会触发哪几个钩子</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/vue-7.png" alt="img"> </p>
<ol start="8">
<li>什么是vue路由</li>
</ol>
<p>后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源，这个对应关系就是后端中的路由；</p>
<p>前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；</p>
<p>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；</p>
<ol start="9">
<li>vue路由的优点以及缺点是什么</li>
</ol>
<p>优点：</p>
<p>　　用户体验好，不需要每次都从服务器全部获取，快速展现给用户</p>
<p>缺点：</p>
<p>不利于 SEO</p>
<p>使用浏览器的前进，后退键的时候会重新发送请求，没有合理利用缓存</p>
<p>单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置</p>
<ol start="10">
<li>怎么定义 vue-router 的动态路由?如何获取动态路由传过来的值</li>
</ol>
<p>可以通过query，param两种方式<br>区别：query通过url传参，刷新页面还在；params属性页面不在</p>
<p>params的类型：</p>
<p>配置路由格式:&#x2F;router&#x2F;:id</p>
<p>传递的方式：在path后面跟上对应的值</p>
<p>传递后形成的路径：&#x2F;router&#x2F;123</p>
<p>query的类类型</p>
<p>配置路由格式:&#x2F;router,也就是普通配置</p>
<p>传递的方式:对象中使用query的key作为传递方式</p>
<p>传递后形成的路径:&#x2F;route?id&#x3D;123</p>
<ol start="11">
<li>请描述vue-router路由守卫的作用？</li>
</ol>
<p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。</p>
<ol start="12">
<li>路由守卫钩子函数里面的三个参数分别是什么</li>
</ol>
<p>to: Route: 即将要进入的目标 <a href="#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1">路由对象</a></p>
<p>from: Route: 当前导航正要离开的路由</p>
<p>next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</p>
<p>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</p>
<ol start="13">
<li>路由守卫的解析流程</li>
</ol>
<p>1 导航被触发。</p>
<p>2 在失活的组件里调用离开守卫。</p>
<p>3 调用全局的 beforeEach 守卫。</p>
<p>4 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</p>
<p>5 在路由配置里调用 beforeEnter。</p>
<p>6 解析异步路由组件。</p>
<p>7 在被激活的组件里调用 beforeRouteEnter。</p>
<p>8 调用全局的 beforeResolve 守卫 (2.5+)。</p>
<p>9 导航被确认。</p>
<p>10 调用全局的 afterEach 钩子。</p>
<p>11 触发 DOM 更新。</p>
<p>12 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</p>
<ol start="14">
<li>vue-router路由传参的方式一共有几种？他们是如何就收传递过来的参数</li>
</ol>
<p>this.$router.push</p>
<p>router.replace(…)</p>
<ol start="15">
<li>什么是计算属性</li>
</ol>
<p>通常我们会在模板中绑定表达式，模板是用来描述视图结构的。<br>如果模板中的表达式存在过多逻辑，模板会变得臃肿不堪，维护变得非常困难。<br>因此为了简化逻辑，当某个属性的值依赖于其他属性的值时，我们可以使用计算属性。</p>
<p>计算属性就是当其依赖属性的值发生变化时，这个属性的值会自动更新，与之相关的 DOM 部分也会同步自动更新</p>
<ol start="16">
<li>组件全局注册和局部注册的区别</li>
</ol>
<p>全局注册是在main.js中去注册组件，这样在所有子组件中就可以使用了</p>
<p>局部注册在components文件夹下的的vue文件中的components属性下去注册组件，这样局部注册的组件在其子组件中不可用</p>
<ol start="17">
<li>请你说一下你对vue组件通信的理解</li>
</ol>
<p>父传子，子传父，兄弟组件</p>
<ol start="18">
<li>子组件如何与父组件进行通信</li>
</ol>
<p>在父组件渲染时  绑定一个自定义事件：</p>
<p>&lt;List @sj&#x3D;”fn” &#x2F;&gt;  自定义事件的名字，自定义事件执行的函数</p>
<p>Fn(n){ }  n 就是传过来的值</p>
<p>在子组件中设置一个事件来触发自定义事件：</p>
<p>函数中写:  this.$emit(‘sj（自定义事件的名字）’, 需要传入的值)</p>
<ol start="19">
<li>非父子组件之间如何进行通信</li>
</ol>
<p>在src下创建一个文件夹lib 在lib中创建一个bus.js 相当于公共文件</p>
<p>在兄弟组件中引用bus.js 文件 ，通过 this.$on(‘自定义事件名称’，执行函数)</p>
<p>在另一个兄弟组件中引用bus.js 文件，通过this.$emit(‘自定义事件名称’, 值)</p>
<ol start="20">
<li>除了组件之间的这种通信方式以外，还是什么方式可以让组件的数据进行共享</li>
</ol>
<p>Vuex</p>
<ol start="21">
<li>请你说一下vue中常用的指令有哪些</li>
</ol>
<p>插入文本:v-text  插入HMTL:v-html  循环:v-for  第二种：v-show  属性绑定:v-bind</p>
<p>双向绑定:v-model  绑定事件:v-on</p>
<ol start="22">
<li>请你说一下为什么使用key</li>
</ol>
<p>key在vue中，有跟它意思一样的关键的作用，整个框架对数据的渲染方面，起到了至关重要的作用</p>
<p>当更新数据的过程中，如果没有key的存在，系统会自动默认更新数据之间所要区分的key值为undefined，根据undefined＝＝undefined，所以数据更新时会忽略特殊比对值的情况下自动按照对比为true的情况去更新渲染数据</p>
<p>特别是中途插入删除数据的过程中，会因为中间某条数据的缺少而进行从从数据更新点之后的所有数据的重新更新以及多出数据的重新创建，这跟vue框架的本质原则相违背。</p>
<p>添加key这个唯一标识后，vue中patch算法会按照前后对比的原则，收尾找相同节点，将数据一一比对，相同的节点就会只做循环，不会发生任何更新，减少多余更新渲染，最后只将更改后的数据渲染到框架中。（sameVnode方法来判断节点是否相同）</p>
<ol start="23">
<li>说一下你对axios的理解</li>
</ol>
<p>基本promise的异步ajax请求库</p>
<p>浏览器端&#x2F;node端都可以使用</p>
<p>支持请求&#x2F;响应拦截器</p>
<p>支持请求取消</p>
<p>请求&#x2F;响应数据转换</p>
<p>批量发送多个请求</p>
<ol start="24">
<li>说一下你对渐进式框架的理解</li>
</ol>
<p>就是一开始不需要你完全掌握它的全部功能特性，可以后续逐步增加功能。没有多做职责之外的事情</p>
<ol start="25">
<li><p>说一下vue单页面和多页面的区别</p>
</li>
<li><p>请你说一下什么是vue的过滤器？你在项目中哪些地方使用过过滤器</p>
</li>
</ol>
<p>概念：本质上是函数；</p>
<p>作用：用户输入数据后，它能够进行处理，并返回一个数据结果；（无return语句不会报错，但是这种过滤器没有丝毫意义）</p>
<p>格式：管道符（ | ）进行连接，而管道符的作用就是：上一个命令的输出可以作为下一个命令的输入；</p>
<p>位置：只能是Mustache表达式、v-bind表达式；“</p>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><a id="next" href="/2022/06/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/">前端面试题<span class="note">较早</span></a><div class="line"></div></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="http://example.com/">@知非</a> 创建，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0" title="v1.8.0">Stellar</a> 作为主题。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://fastly.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://fastly.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://fastly.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
