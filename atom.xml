<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你又来看我啦</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-29T13:07:23.802Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>知非</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue3中的Ref</title>
    <link href="http://example.com/2022/07/12/Vue3/ref%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/07/12/Vue3/ref%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-12T13:19:26.000Z</published>
    <updated>2022-08-29T13:07:23.802Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue2中的ref属性"><a href="#Vue2中的ref属性" class="headerlink" title="Vue2中的ref属性"></a>Vue2中的ref属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div ref=&quot;boxRef&quot;&gt;value&lt;/div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li v-for=&quot;item of 3&quot; :key=&quot;item&quot; :ref=&quot;liRef&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">getDom()&#123;</span><br><span class="line">    const boxRef = this.$refs.boxRef.innerHTML;</span><br><span class="line">    const lisRef = this.$refs.liRef;</span><br><span class="line">    console.log(boxRef,lisRef,lisRef[1].innerHTML)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">box,[li,li,li,li],&#x27;2&#x27;</span><br></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>Vue2中可以通过ref直接操作单个DOM和组件，如：this.$ref.boxRef;</li><li>Vue2中可以通过ref批量操作多个DOM和组件，如：this.$refs.lisRef[1];</li></ul></blockquote><h3 id="Vue3中的ref属性"><a href="#Vue3中的ref属性" class="headerlink" title="Vue3中的ref属性"></a>Vue3中的ref属性</h3><p>在 Vue3 中没有 $refs，因此 Vue3 中通过 ref 属性获取元素就不能按照 vue2 的方式来获取。Vue3 需要借助生命周期方法，因为在 setup 执行时，template 中的元素还没挂载到页面上，所以必须在 mounted 之后才能获取到元素。</p><h4 id="操作单个-DOM-或者组件"><a href="#操作单个-DOM-或者组件" class="headerlink" title="操作单个 DOM 或者组件"></a>操作单个 DOM 或者组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref=&quot;box&quot;&gt;box&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; onMounted, ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup()&#123;</span><br><span class="line">     // 1. 先定义一个空的响应式数据( ref 定义的)</span><br><span class="line">    // 2 setup中返回定义的数据，需要获取哪个 dom 元素，就在对应元素上使用 ref 属性绑定该数据即可。</span><br><span class="line">    const box = ref(null);</span><br><span class="line">    const getDom = () =&gt; &#123;</span><br><span class="line">      console.log(box.value)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">      getDom();</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">      box</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>： 先申明 ref 响应式数据，再返回给模版使用，模板中通过 ref 绑定数据；</p></blockquote><h4 id="获取-v-for-遍历的-DOM-或者-组件"><a href="#获取-v-for-遍历的-DOM-或者-组件" class="headerlink" title="获取 v-for 遍历的 DOM 或者 组件"></a>获取 v-for 遍历的 DOM 或者 组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li </span><br><span class="line">      v-for=&quot;item in cityList&quot; </span><br><span class="line">      :key=&quot;item.id&quot; </span><br><span class="line">      :ref=&quot;getDom&quot;&gt;</span><br><span class="line">      &#123;&#123;item.city&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; onMounted, reactive&#125; from &#x27;vue&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup()&#123;</span><br><span class="line">    const cityList = reactive([</span><br><span class="line">      &#123; city:&#x27;武汉&#x27;, id: &#x27;027&#x27;&#125;,</span><br><span class="line">      &#123; city:&#x27;南京&#x27;, id: &#x27;025&#x27;&#125;,</span><br><span class="line">      &#123; city:&#x27;重庆&#x27;, id: &#x27;023&#x27;&#125;,</span><br><span class="line">    ]);</span><br><span class="line">    // 1.定义一个空数组，接收所有的dom</span><br><span class="line">    const lis = [];</span><br><span class="line">    // 2. 定义一个函数，往空数组push dom</span><br><span class="line">    const getDom = (el) =&gt; &#123;</span><br><span class="line">      lis.push(el);</span><br><span class="line">    &#125;</span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">      console.log(lis,lis[0])</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;</span><br><span class="line">      cityList,</span><br><span class="line">      getDom,</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结： 先定义一个空数组，再定义一个函数获取元素，并把该函数绑定到 ref 上（必须动态绑&gt;?&gt; 定），最后在函数中可以通过参数得到单个元素，这个元素一般可以放到数组中。</p></blockquote><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><blockquote><p>在组件更新的时候会重复的添加dom元素给数组</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ref 获取 v-for 遍历的DOM元素，需要在组件更新的时候重置接受dom元素的数组。</span><br><span class="line">onBeforeUpdate(()=&gt;&#123;</span><br><span class="line">  list = []</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Vue3中的Ref</summary>
    
    
    
    <category term="Vue3" scheme="http://example.com/categories/Vue3/"/>
    
    
    <category term="-Vue3" scheme="http://example.com/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>React性能优化</title>
    <link href="http://example.com/2022/06/13/React/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2022/06/13/React/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2022-06-13T02:50:39.000Z</published>
    <updated>2022-08-18T01:30:26.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>React凭借着Virtual DOM和diff算法拥有高效的性能，但是某些情况下，性能明显可以进一步提高</p><blockquote><p>在我们类组件通过调用setState方法，就会导致render，父组件一旦发生render渲染，子组件一定会执行render渲染，理想状态只调用该路径下的组件render，但是react的默认做法是调用所有组件的render，在对生成的虚拟DOM进行对比，如果没变就不进行更新，这种diff算法对比是明显的性能浪费的情况</p></blockquote><h2 id="如何做"><a href="#如何做" class="headerlink" title="如何做"></a>如何做</h2><p>在React中如何避免不必要的render，主要手段是通过shouldComponentUpdate、PureComponent、React.memo，这三种形式<br>除此之外常见的性能优化手段有</p><ul><li>避免使用内联函数</li><li>使用React Fragments避免额外标记</li><li>使用Immutable</li><li>懒加载组件</li><li>事件绑定方式</li><li>服务端渲染</li></ul><h3 id="避免使用内联函数"><a href="#避免使用内联函数" class="headerlink" title="避免使用内联函数"></a>避免使用内联函数</h3><blockquote><p>如果我们使用内联函数，则每次调用render函数时都会创建一个新的函数实例，如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default class InlineFunctionComponent extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Welcome Guest&lt;/h1&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; onClick=&#123;(e) =&gt; &#123; this.setState(&#123;inputValue: e.target.value&#125;) &#125;&#125; value=&quot;Click For Inline Function&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们应该在组件内部创建一个函数，并将事件绑定到该函数本身。这样每次调用render时 就不会生成单独的函数实例，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default class InlineFunctionComponent extends React.Component &#123;</span><br><span class="line">  </span><br><span class="line">  setNewStateData = (event) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      inputValue: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Welcome Guest&lt;/h1&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; onClick=&#123;this.setNewStateData&#125; value=&quot;Click For Inline Function&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用React-Fragments避免额外标记"><a href="#使用React-Fragments避免额外标记" class="headerlink" title="使用React Fragments避免额外标记"></a>使用React Fragments避免额外标记</h3><ul><li>用户创建组件时，每个组件应具有单个父标签。父级不能有两个标签，所以顶部要有一个公共标签，所以我们经常在组件顶部添加额外标签div</li><li>这个额外标签除了充当父标签之外，并没有其他作用，这时候则可以使用fragment</li><li>其不会向组件引入任何额外标记，但它可以作为父级标签的作用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default class NestedRoutingComponent extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;h1&gt;This is the Header Component&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;Welcome To Demo Page&lt;/h2&gt;</span><br><span class="line">            &lt;/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="事件绑定方式"><a href="#事件绑定方式" class="headerlink" title="事件绑定方式"></a>事件绑定方式</h3><ul><li>在事件绑定方式中，我们了解到四种事件绑定的方式</li><li>从性能方面考虑，在render方法中使用bind和render方法中使用箭头函数这两种形式在每次组件render的时候都会生成新的方法实例，性能欠缺</li><li>而constructor中bind事件与与定义阶段使用箭头函数绑定这两种形式只会生成一个方法实例，性能方面会有所改善</li></ul><h3 id="使用Imnutable"><a href="#使用Imnutable" class="headerlink" title="使用Imnutable"></a>使用Imnutable</h3><ul><li>使用Immutable可以给React带来性能的优化，主要体现在减少渲染的次数</li><li>在做react性能优化的时候，为了避免重复，我们会在shouldComponentUpdate()中做对比，当返回true执行render方法</li><li>Immutable通过is方法则可以完成对比，而无需像一样通过深度比较的方式比较</li></ul><h3 id="懒加载组件"><a href="#懒加载组件" class="headerlink" title="懒加载组件"></a>懒加载组件</h3><ul><li>从工程方面考虑，webpack存在代码拆分能力，可以为应用创建多个包，并在运行时动态加载，减少初始包的大小</li><li>而在react中使用到了Supense和lazy组件实现代码拆分功能，基本使用如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const johanComponent = React.lazy(() =&gt; import(/* webpackChunkName: &quot;johanComponent&quot; */ &#x27;./myAwesome.component&#x27;));</span><br><span class="line"> </span><br><span class="line">export const johanAsyncComponent = props =&gt; (</span><br><span class="line">  &lt;React.Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt;</span><br><span class="line">    &lt;johanComponent &#123;...props&#125; /&gt;</span><br><span class="line">  &lt;/React.Suspense&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><ul><li>采用服务端渲染方式，用户可以更快的看到渲染完成的页面</li><li>服务端渲染，需要一个node服务，可以用express、koa等，调用react的renderTostring方法，将组件渲染成字符串，在输出到响应中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; renderToString &#125; from &quot;react-dom/server&quot;;</span><br><span class="line">import MyPage from &quot;./MyPage&quot;;</span><br><span class="line">app.get(&quot;/&quot;, (req, res) =&gt; &#123;</span><br><span class="line">  res.write(&quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;);</span><br><span class="line">  res.write(&quot;&lt;div id=&#x27;content&#x27;&gt;&quot;);  </span><br><span class="line">  res.write(renderToString(&lt;MyPage/&gt;));</span><br><span class="line">  res.write(&quot;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>客户端使用render方法来生成html<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import MyPage from &quot;./MyPage&quot;;</span><br><span class="line">ReactDOM.render(&lt;MyPage /&gt;, document.getElementById(&#x27;app&#x27;));</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>除此之外，还存在的优化手段有组件拆分、合理使用hooks等性能优化手段</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面初步学习，我们了解到react常见的性能优化可以分成三个层面来执行</p><ul><li>代码层面</li><li>工程层面</li><li>框架机制层面</li></ul><p>通过这三个层面的优化结合，能够使基于react项目的性能更上一层楼。</p>]]></content>
    
    
    <summary type="html">浅析React中性能优化的手段</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="-React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>为什么访问data中的属性不需要带data</title>
    <link href="http://example.com/2022/06/13/Vue3/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BF%E9%97%AEdata%E5%B1%9E%E6%80%A7%E4%B8%8D%E9%9C%80%E8%A6%81%E5%B8%A6data/"/>
    <id>http://example.com/2022/06/13/Vue3/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BF%E9%97%AEdata%E5%B1%9E%E6%80%A7%E4%B8%8D%E9%9C%80%E8%A6%81%E5%B8%A6data/</id>
    <published>2022-06-13T01:13:23.000Z</published>
    <updated>2022-08-16T06:35:27.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么访问data中的属性不需要带data"><a href="#为什么访问data中的属性不需要带data" class="headerlink" title="为什么访问data中的属性不需要带data"></a>为什么访问data中的属性不需要带data</h3><blockquote><p>vue中访问属性代理this.data.xxx 转换 this.xxx 的实现</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> /** 将 某一个对象的属性 访问 映射到 对象的某一个属性成员上 */</span><br><span class="line">function proxy( target, prop, key ) &#123;</span><br><span class="line">  Object.defineProperty( target, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get () &#123;</span><br><span class="line">      return target[ prop ][ key ];</span><br><span class="line">    &#125;,</span><br><span class="line">    set ( newVal ) &#123;</span><br><span class="line">      target[ prop ][ key ] = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">为什么访问data中的属性不需要带data</summary>
    
    
    
    <category term="Vue3" scheme="http://example.com/categories/Vue3/"/>
    
    
    <category term="-Vue3" scheme="http://example.com/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Event Loop</title>
    <link href="http://example.com/2022/05/17/JavaScript/%E4%BB%80%E4%B9%88%E6%98%AFEventloop/"/>
    <id>http://example.com/2022/05/17/JavaScript/%E4%BB%80%E4%B9%88%E6%98%AFEventloop/</id>
    <published>2022-05-17T10:13:26.000Z</published>
    <updated>2022-08-24T14:05:17.541Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是事件循环（Event-Loop）？"><a href="#什么是事件循环（Event-Loop）？" class="headerlink" title="什么是事件循环（Event Loop）？"></a>什么是事件循环（Event Loop）？</h3><h3 id="一：首先要明确：js的执行机制"><a href="#一：首先要明确：js的执行机制" class="headerlink" title="一：首先要明确：js的执行机制"></a>一：首先要明确：js的执行机制</h3><ul><li><p>1.从上到下依次执行</p></li><li><p>2.当某一行代码发生错误时，停止执行下面的代码</p></li><li><p>3.先执行同步代码，在执行异步代码</p></li></ul><h3 id="二：事件循环的执行过程"><a href="#二：事件循环的执行过程" class="headerlink" title="二：事件循环的执行过程"></a>二：事件循环的执行过程</h3><ul><li><p>1.同步代码先执行：调用栈执行后直接出栈</p></li><li><p>2.异步代码放入回调队列：等待调用栈空后，进入执行</p></li><li><p>3.宏任务和微任务都属于异步代码，微任务先执行，宏任务后执行</p></li><li><p>4.微任务在DOM渲染前执行，宏任务在DOM渲染后执行</p></li></ul><h3 id="三：宏任务和微任务的根本区别"><a href="#三：宏任务和微任务的根本区别" class="headerlink" title="三：宏任务和微任务的根本区别"></a>三：宏任务和微任务的根本区别</h3><ul><li><p>1.常见的宏任务有：setTimeout setInterval ajax DOM事件</p></li><li><p>2.常见的微任务有：promise async&#x2F;await</p></li><li><p>3.微任务的执行时间早于宏任务</p></li><li><p>4.微任务是由es6语法规定的，宏任务是浏览器规定的</p></li></ul><h3 id="四：事件循环的整体流程"><a href="#四：事件循环的整体流程" class="headerlink" title="四：事件循环的整体流程"></a>四：事件循环的整体流程</h3><ul><li><p>1.执行完call stack调用栈中的同步代码</p></li><li><p>2.执行微任务队列中的微任务代码</p></li><li><p>3.尝试DOM渲染</p></li><li><p>4.触发Event Loop 反复询问callbackQueue回调队列中是否还有需要执行的语句，如果有，则放入call stack调用栈中继续执行</p></li></ul><h3 id="五：经典案例"><a href="#五：经典案例" class="headerlink" title="五：经典案例"></a>五：经典案例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;start&#x27;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(333);</span><br><span class="line">&#125;); // 安排明天干的活</span><br><span class="line">Promise.resolve(&#x27;x&#x27;).then(() =&gt; &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(5); // 小任务无限的加 今天干完否则下不了班</span><br><span class="line">    //nodejs 有小任务限制，跳过直接到宏任务</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;end&#x27;);</span><br><span class="line">输入结果：start--&gt;end--&gt;3---&gt;4--&gt;5--&gt;333</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：</p><blockquote><p>1.start和end属于同步代码优先执行<br>2.promise里的代码也属于同步代码，但.then里的代码属于异步代码中的微任务，稍后执行<br>3.setTimeout属于异步代码中的宏任务，最后执行</p></blockquote>]]></content>
    
    
    <summary type="html">什么是事件循环（Event Loop）？</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="-JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Element-Form表单验证</title>
    <link href="http://example.com/2022/05/06/Vue/elementForm%E9%AA%8C%E8%AF%81/"/>
    <id>http://example.com/2022/05/06/Vue/elementForm%E9%AA%8C%E8%AF%81/</id>
    <published>2022-05-06T13:19:26.000Z</published>
    <updated>2022-08-26T07:05:31.811Z</updated>
    
    <content type="html"><![CDATA[<h3 id="校验只能是数字"><a href="#校验只能是数字" class="headerlink" title="校验只能是数字"></a>校验只能是数字</h3><blockquote><p>设置rule中的type为number和v-model加上.number </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-form-item label=&quot;编码&quot; prop=&quot;number&quot;&gt;</span><br><span class="line">    &lt;el-input v-model.number=&quot;addForm.number&quot; placeholder=&quot;编码&quot; /&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">rule =  reactive(&#123;number: [</span><br><span class="line">    &#123;</span><br><span class="line">        type: &quot;number&quot;,</span><br><span class="line">        message: &quot;只能是数字&quot;,</span><br><span class="line">        trigger: &quot;blur&quot;,</span><br><span class="line">        required: false,</span><br><span class="line">    &#125;,</span><br><span class="line">]&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>required设置必填 将其设为false 即可以为空又能进行验证</p></blockquote>]]></content>
    
    
    <summary type="html">浅析Element-Form表单验证</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="-Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue中的nextTick</title>
    <link href="http://example.com/2022/04/13/Vue/nextTick/"/>
    <id>http://example.com/2022/04/13/Vue/nextTick/</id>
    <published>2022-04-13T11:11:07.000Z</published>
    <updated>2022-08-24T13:59:10.456Z</updated>
    
    <content type="html"><![CDATA[<p>vm.$nextTick( [callback] )</p><blockquote><p>官方解释：将回调延迟到下次DOM更新循环之后执行。</p></blockquote><p>要理解这句话，首先要了解一下vue的异步更新队列，vue异步执行dom更新。只要观察到数据变化，不会立即更新DOM，vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。</p><p>如果同一个数据被多次改变，只会被推到队列中一次。例如，当你设置vm.someData &#x3D;  ‘new value’,对应的dom更新会被推到一个队列里，该组件不会立即重新渲染，会在当前tick完毕后，在下一个tick中渲染dom。在事件循环中，每进行一次循环操作称为tick。而nextTick函数就是vue提供的一个实例方法，数据更新后等待下一个tick里dom更新完后执行回调，回调的this自动绑定到调用它的实例上。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">html: </span><br><span class="line">&lt;span class=&quot;test&quot;&gt;&#123;&#123;egData&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;el-button @click=&quot;changeData&quot;&gt;改变&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">js:</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            egData: &#x27;old Message&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeData () &#123;</span><br><span class="line">          this.egData = &#x27;new Message&#x27;</span><br><span class="line">          console.log($(&#x27;.test&#x27;).html(), &#x27;-----------------------&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong> </p><ul><li>第一次点击输出 old Message ———————–，</li><li>第二次点击输出 new Message ———————–</li></ul><p>使用$nextTick:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">js:</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            egData: &#x27;old Message&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeData () &#123;</span><br><span class="line">          this.egData = &#x27;new Message&#x27;</span><br><span class="line">          this.$nextTick(function () &#123;</span><br><span class="line">            console.log($(&#x27;.test&#x27;).html(), &#x27;-----------------------&#x27;)</span><br><span class="line">          &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>结果：不管第几次点击，都输出 new Message ———————–</p></blockquote><h3 id="nextTick使用场景"><a href="#nextTick使用场景" class="headerlink" title="$nextTick使用场景"></a>$nextTick使用场景</h3><ul><li><p>1、数据更新后想要马上操作新的DOM，需要把操作写在nextTick的回调里</p></li><li><p>2、在created钩子函数里需要操作DOM，也可以把操作写在nextTick的回调里,(created钩子函数里还没有挂载dom，所以直接操作会有问</p></li></ul><blockquote><p>this.$nextTick()将回调延迟到下次DOM更新循环之后执行。在修改数据之后立即使用它，然后等待DOM更新。它跟全局方法Vue.nextTick一样，不同的是回调的this自动绑定到调用它的实例上。</p></blockquote><blockquote><p>nextTick的由来：由于VUE的数据驱动视图更新，是异步的，即修改数据的当下，视图不会立刻更新，而是等同一事件中的所有数据变化完成之后，再统一进行视图更新。</p></blockquote><blockquote><p>nextTick的触发时机：在同一事件循环中的数据变化后，DOM完成更新，立即执行nextTick(callback)内的回调。</p></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>需要在视图更新之后，基于新的视图进行操作。</p><blockquote><p>以上出现了事件循环的概念，其涉及到JS的运行机制，包括主线程的执行栈、异步队列、异步API、时间循环的写作。大致可以理解为：主线程完成同步环境执行，查询任务队列，提取队首的任务，放入主线程中执行；执行完毕，再重复该操作，该过程称为事件循环。而主线程的每次读取任务队列操作，是一个事件循环的开始。异步callback不可能处在同一事件循环中。</p></blockquote><h3 id="简单总结事件循环"><a href="#简单总结事件循环" class="headerlink" title="简单总结事件循环"></a>简单总结事件循环</h3><p>同步代码执行→查找异步队列，推入执行栈，执行callback[事件循环1]→查找异步队列，推入执行栈，执行callback2[事件循环2]…</p><p>即每个异步callback，最终都会形成自己独立的一个事件循环。</p><h3 id="nextTick触发的时机"><a href="#nextTick触发的时机" class="headerlink" title="nextTick触发的时机"></a>nextTick触发的时机</h3><p>结合nextTick的由来，可以推出每个事件循环中，nextTick触发的时机：同一事件循环中的代码执行完毕→DOM更新→nextTick callback触发。</p><p>ps:上文中的任务队列、消息队列、异步队列指向同一个东西，均指macrotask queue。</p><p>用法：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。</p><p>在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中<br>在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。</p><p>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中</p><p>为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;nextTick&lt;/title&gt;</span><br><span class="line">        &lt;script src=&quot;./js/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">          &lt;div ref=&quot;msgDiv&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">          &lt;div v-if=&quot;msg1&quot;&gt;Message got outside 1 $nextTick: &#123;&#123;msg1&#125;&#125;&lt;/div&gt;</span><br><span class="line">          &lt;div v-if=&quot;msg2&quot;&gt;Message got inside 2 $nextTick: &#123;&#123;msg2&#125;&#125;&lt;/div&gt;</span><br><span class="line">          &lt;div v-if=&quot;msg3&quot;&gt;Message got outside 3 $nextTick: &#123;&#123;msg3&#125;&#125;&lt;/div&gt;</span><br><span class="line">          &lt;button @click=&quot;changeMsg&quot;&gt;</span><br><span class="line">            Change the Message</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            new Vue(&#123;</span><br><span class="line">              el: &#x27;.app&#x27;,</span><br><span class="line">              data: &#123;</span><br><span class="line">                msg: &#x27;Hello Vue.&#x27;,</span><br><span class="line">                msg1: &#x27;&#x27;,</span><br><span class="line">                msg2: &#x27;&#x27;,</span><br><span class="line">                msg3: &#x27;&#x27;</span><br><span class="line">              &#125;,</span><br><span class="line">              methods: &#123;</span><br><span class="line">                changeMsg() &#123;</span><br><span class="line">                  this.msg = &quot;Hello world.&quot;</span><br><span class="line">                  this.msg1 = this.$refs.msgDiv.innerHTML</span><br><span class="line">                  this.$nextTick(() =&gt; &#123;</span><br><span class="line">                    this.msg2 = this.$refs.msgDiv.innerHTML</span><br><span class="line">                  &#125;)</span><br><span class="line">                  this.msg3 = this.$refs.msgDiv.innerHTML</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>msg1和msg3显示的内容还是变换之前的，而msg2显示的内容是变换之后的。其根本原因是因为Vue中DOM更新是异步的</p><p>需要注意的是，在 created 和 mounted 阶段，如果需要操作渲染后的试图，也要使用 nextTick 方法。</p><p>官方文档说明：</p><blockquote><p>注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</p></blockquote>]]></content>
    
    
    <summary type="html">nextTick的原理和应用场景</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="-Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>??和?.的区别</title>
    <link href="http://example.com/2022/04/11/JavaScript/Js%E4%B8%AD%E9%97%AE%E5%8F%B7%E5%92%8C%E9%97%AE%E5%8F%B7%E7%82%B9%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/04/11/JavaScript/Js%E4%B8%AD%E9%97%AE%E5%8F%B7%E5%92%8C%E9%97%AE%E5%8F%B7%E7%82%B9%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-04-11T03:23:20.000Z</published>
    <updated>2022-08-19T14:15:32.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="空值合并操作符（-）"><a href="#空值合并操作符（-）" class="headerlink" title="空值合并操作符（??）"></a>空值合并操作符（??）</h3><p>只有当左侧为null和undefined时，才会返回右侧的数 空值合并操作符（??）是一个逻辑操作符，当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。</p><p>与逻辑或操作符（||）不同，逻辑或操作符会在左侧操作数为假值时返回右侧操作数。也就是说，如果使用 || 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如，’’ 或 0）时。见下面的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">null ?? 20 </span><br><span class="line">undefined ?? 3</span><br><span class="line">&#x27;&#x27; ?? 3</span><br><span class="line">0 ?? 4</span><br><span class="line"># 20</span><br><span class="line"># 3</span><br><span class="line"># &#x27;&#x27;</span><br><span class="line"># 0</span><br></pre></td></tr></table></figure><h3 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符( ?. )"></a>可选链操作符( ?. )</h3><p>可选链操作符( ?. )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。</p><p>?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(nullish ) (null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const dog = &#123;</span><br><span class="line"> prop: &#123;</span><br><span class="line">    name: &#x27;小七&#x27;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">dog?.prop</span><br><span class="line"># &#123;name: &#x27;小七&#x27;&#125;</span><br><span class="line"></span><br><span class="line">dog?.prop?.name</span><br><span class="line"># &#x27;小七&#x27;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">??和?.的区别</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="-JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>发布订阅者模式和观察者模式的区别</title>
    <link href="http://example.com/2022/03/19/JavaScript/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/03/19/JavaScript/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-03-19T09:03:26.000Z</published>
    <updated>2022-08-16T01:52:17.125Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是观察者模式"><a href="#什么是观察者模式" class="headerlink" title="什么是观察者模式"></a>什么是观察者模式</h3><blockquote><p>定义：当对象之间存在一对多的依赖关系的时候，其中一个对象的状态发生改变，所有一栏他的对象都会收到通知，这就是观察者模式。</p></blockquote><ul><li>在观察者模式中，只有两种主题：目标对象(Object)和观察者(Observer)<blockquote><p>目标对象Subject</p><ul><li>维护观察者列表<code>oberverList</code></li></ul></blockquote><ul><li>定义添加观察者的方法</li><li>当自身发生变化后，通过调用自己的notify方法依次通知每个观察者执行<code>update</code>方法</li></ul></li><li>观察者Observer需要实现update方法，供目标对象调用。update方法中可以执行自定义的业务逻辑—弟子们需要定义接受任务通知后的方法，例如去抢任务或者任务不合适继续等待下个任务。</li></ul><h3 id="什么是发布定义者模式"><a href="#什么是发布定义者模式" class="headerlink" title="什么是发布定义者模式"></a>什么是发布定义者模式</h3><blockquote><p>定义：基于一个事件（主题）通道，希望接受通知的对象Subscriber通过自定义事件订阅主题，被激活事件的对象Publisher通过发布主题事件的方式通知各个订阅该主题的Subscriber对象。</p></blockquote><p>因此发布者订阅模式与观察者模式相比，发布订阅模式中有三个角色，发布者Publisher，事件调度中心Event Channel，订阅者Subscriber。<br>目标对象Subject:<br>任务发布者 – 发布者Publisher<br>中介功能 – Event Channel</p><ul><li>维护任务类型，以及每种任务下的订阅情况</li><li>给订阅者提供订阅功能 – subscribe功能</li><li>当主题发布任务后，中介会给所有订阅者发布任务 – publish功能</li></ul><p>任务接受者 – Subscriber<br>观察者Observer需要实现update方法，供目标调用。update方法中可以执行自定义的业务逻辑</p><blockquote><p>发布者和订阅者都不知道对方的存在。需要第三方中介，将订阅者和发布者串联起来，利用中介过滤和分配所有输入的消息。也就是说发布-订阅者模式用来处理不同系统组件的信息交流，即使这些组件不知道对方的存在。<br>例如 ：<br>平台提供了消息订阅的功能，如果你选择订阅，平台更新电视剧之后会第一时间发消息通知你，订阅后，你就可以愉快的追剧了。这个案例中 电视剧就是发布者Publisher，追剧人就是订阅者Subscribe，平台则承担了事件通道Event Channel功能。</p></blockquote><p>总结：</p><table><thead><tr><th>设计模式</th><th>观察者模式</th><th>订阅发布者模式</th></tr></thead><tbody><tr><td>主体</td><td>Object观察者、Subject目标对象</td><td>Publisher发布者、Event Channel事件中心、Subscribe订阅者</td></tr><tr><td>主体关系</td><td>subject中通过observerList记录ObServer</td><td>Publisher和Subscribe不知道对方，通过中介联系</td></tr><tr><td>优点</td><td>角色明确，Subject和Object要遵循约定的成员方法</td><td>松散耦合，灵活度高，通常应用在异步编程中</td></tr><tr><td>缺点</td><td>紧耦合</td><td>当事件类型变多时，会增加维护成本</td></tr><tr><td>使用案例</td><td>双向数据绑定</td><td>事件总线EventBus</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">发布订阅者模式和观察者模式的区别</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="-JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>受控组件和非受控组件</title>
    <link href="http://example.com/2021/12/07/React/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/"/>
    <id>http://example.com/2021/12/07/React/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/</id>
    <published>2021-12-07T12:21:07.000Z</published>
    <updated>2022-08-24T14:10:23.549Z</updated>
    
    
    <summary type="html">受控组件和非受控组件的区别</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="-React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>什么是骨架屏</title>
    <link href="http://example.com/2021/11/19/Html/%E9%AA%A8%E6%9E%B6%E5%B1%8F/"/>
    <id>http://example.com/2021/11/19/Html/%E9%AA%A8%E6%9E%B6%E5%B1%8F/</id>
    <published>2021-11-19T12:26:19.000Z</published>
    <updated>2022-08-29T13:07:41.395Z</updated>
    
    
    <summary type="html">浅析骨架屏的实现和应用</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="-Html" scheme="http://example.com/tags/Html/"/>
    
    <category term="-前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序uCharts层级太高</title>
    <link href="http://example.com/2021/11/07/Wx/ucharts%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/11/07/Wx/ucharts%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</id>
    <published>2021-11-07T02:19:21.000Z</published>
    <updated>2022-08-22T00:26:26.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序图表层级过高问题"><a href="#微信小程序图表层级过高问题" class="headerlink" title="微信小程序图表层级过高问题"></a>微信小程序图表层级过高问题</h3><ul><li><p>因 canvas 在微信小程序是原生组件，如果使用自定义 tabbar 或者自定义导航栏，图表则会超出预期，此时需要给组件的 canvas2d 传值 true 来使用 type&#x3D;’2d’ 的功能。</p></li><li><p>开启此模式后，一定要在组件上自定义 canvasId，不能为数字开头、要为随机字符串！不能真机调试，开发者工具显示不正常，图表层级会变高，而正常预览或者发布上线则是正常状态，请以真机预览为准。因微信开发者工具显示不正确，canvas2d 这种模式下给调试带来了困难，开发时，可以先用 :canvas2d&#x3D;”false” 来调试，预览无误后再改成 true。<br>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;charts-box&quot;&gt;</span><br><span class="line">&lt;qiun-data-charts type=&quot;mount&quot; :opts=&quot;opts1&quot; :chartData=&quot;chartData1&quot; </span><br><span class="line">       :canvas2d=&quot;true&quot; canvasId=&quot;barCanvasId&quot; /&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="开启canvas2d后图表不显示问题"><a href="#开启canvas2d后图表不显示问题" class="headerlink" title="开启canvas2d后图表不显示问题"></a>开启canvas2d后图表不显示问题</h3><ul><li>开启 canvas2d 后，需要手动指定 canvasId，并且父元素不能含有 v-if，否则会导致获取不到 dom 节点问题，请将 v-if 改成 v-show。</li></ul>]]></content>
    
    
    <summary type="html">uCharts中图表层级过高，遮挡弹出框等问题</summary>
    
    
    
    <category term="Wx" scheme="http://example.com/categories/Wx/"/>
    
    
    <category term="-Wx" scheme="http://example.com/tags/Wx/"/>
    
    <category term="-uCharts" scheme="http://example.com/tags/uCharts/"/>
    
  </entry>
  
  <entry>
    <title>arguments参数</title>
    <link href="http://example.com/2021/10/21/JavaScript/arguments%E5%8F%82%E6%95%B0/"/>
    <id>http://example.com/2021/10/21/JavaScript/arguments%E5%8F%82%E6%95%B0/</id>
    <published>2021-10-21T11:12:26.000Z</published>
    <updated>2022-08-26T02:58:38.244Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是arguments"><a href="#什么是arguments" class="headerlink" title="什么是arguments"></a>什么是arguments</h3><blockquote><p>arguments是一个对应于传递参数的 类数组（array-like）对象</p></blockquote><p><strong>array-like</strong>意味着他不是一个数组类型，而是一个对象类型</p><ul><li>但是它却拥有数组的一些特性，比如说length，比如说可以通过index索引</li><li>但是它却没有数组的一些方法，比如forEach、Map等</li></ul><h3 id="arguments转成array"><a href="#arguments转成array" class="headerlink" title="arguments转成array"></a>arguments转成array</h3><ul><li><p>通过遍历的方式进行转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = []</span><br><span class="line">for(let i = 0;i &lt; arguments.length;i &lt;++)&#123;</span><br><span class="line">    arr.push(arguments[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过call</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = Array.prototype.slice.call(arguments)</span><br><span class="line">let arr2 = [].slice.call(arguments)</span><br></pre></td></tr></table></figure></li><li><p>ES6中通过Array.from()或者扩展运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = Array.from(arguments)</span><br><span class="line">const arr2 = [...arguments]</span><br></pre></td></tr></table></figure></li></ul><h3 id="箭头函数中不可用array"><a href="#箭头函数中不可用array" class="headerlink" title="箭头函数中不可用array"></a>箭头函数中不可用array</h3><ul><li>箭头函数是不绑定arguments的，所以我们在箭头函数中使用arguments会去上层作用查找</li><li>而在浏览器全部是没有arguments的</li><li>如果想在箭头函数中，也能拿到传递的所有参数，则可以使用ES6的剩余参数 <strong>…args</strong></li><li>或者也可以使用rest参数代替</li></ul>]]></content>
    
    
    <summary type="html">浅析ES6新增的arguments</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="-JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="-ES6" scheme="http://example.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>实现数组扁平化</title>
    <link href="http://example.com/2021/10/17/JavaScript/%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3/"/>
    <id>http://example.com/2021/10/17/JavaScript/%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3/</id>
    <published>2021-10-17T03:23:20.000Z</published>
    <updated>2022-08-18T01:40:26.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-方法一：普通的递归实"><a href="#1-方法一：普通的递归实" class="headerlink" title="1. 方法一：普通的递归实"></a>1. 方法一：普通的递归实</h3><blockquote><p>普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接。我们来看下这个方法是如何实现的，如下所示</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 方法1</span><br><span class="line">var a = [1, [2, [3, 4, 5]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  let result = [];</span><br><span class="line"></span><br><span class="line">  for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if(Array.isArray(arr[i])) &#123;</span><br><span class="line">      result = result.concat(flatten(arr[i]));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">flatten(a);  //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><p>从上面这段代码可以看出，最后返回的结果是扁平化的结果，这段代码核心就是循环遍历过程中的递归操作，就是在遍历过程中发现数组元素还是数组的时候进行递归操作，把数组的结果通过数组的 concat 方法拼接到最后要返回的 result 数组上，那么最后输出的结果就是扁平化后的数组</p><h3 id="2-方法二：利用-reduce-函数迭代"><a href="#2-方法二：利用-reduce-函数迭代" class="headerlink" title="2. 方法二：利用 reduce 函数迭代"></a>2. 方法二：利用 reduce 函数迭代</h3><blockquote><p>从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么我们其实也可以用 reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 方法2</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.reduce(function(prev, next)&#123;</span><br><span class="line">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr));//  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><h3 id="3-方法三：扩展运算符实现"><a href="#3-方法三：扩展运算符实现" class="headerlink" title="3. 方法三：扩展运算符实现"></a>3. 方法三：扩展运算符实现</h3><blockquote><p>这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的，还是来看一下代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方法3</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><p>从执行的结果中可以发现，我们先用数组的 some 方法把数组中仍然是组数的项过滤出来，然后执行 concat 操作，利用 ES6 的展开运算符，将其拼接到原数组中，最后返回原数组，达到了预期的效果。</p><p>前三种实现数组扁平化的方式其实是最基本的思路，都是通过最普通递归思路衍生的方法，尤其是前两种实现方法比较类似。值得注意的是 reduce 方法，它可以在很多应用场景中实现，由于 reduce 这个方法提供的几个参数比较灵活，能解决很多问题，所以是值得熟练使用并且精通的</p><h3 id="4-方法四：split-和-toString-共同处理"><a href="#4-方法四：split-和-toString-共同处理" class="headerlink" title="4. 方法四：split 和 toString 共同处理"></a>4. 方法四：split 和 toString 共同处理</h3><p>我们也可以通过 split 和 toString 两个方法，来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 方法4</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.toString().split(&#x27;,&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组，你可以在控制台执行一下查看结果。</p><h3 id="5-方法五：调用-ES6-中的-flat"><a href="#5-方法五：调用-ES6-中的-flat" class="headerlink" title="5. 方法五：调用 ES6 中的 flat"></a>5. 方法五：调用 ES6 中的 flat</h3><blockquote><p>我们还可以直接调用 ES6 中的 flat 方法，可以直接实现数组扁平化。先来看下 flat 方法的语法：<br>arr.flat([depth])<br>其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。那么如果多层的该怎么处理呢？参数也可以传进 Infinity，代表不论多少层都要展开。那么我们来看下，用 flat 方法怎么实现，请看下面的代码。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 方法5</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  return arr.flat(Infinity);</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><p>可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。<br>因此，你在编程过程中，发现对数组的嵌套层数不确定的时候，最好直接使用 Infinity，可以达到扁平化。下面我们再来看最后一种场景</p><h3 id="6-方法六：正则和-JSON-方法共同处理"><a href="#6-方法六：正则和-JSON-方法共同处理" class="headerlink" title="6. 方法六：正则和 JSON 方法共同处理"></a>6. 方法六：正则和 JSON 方法共同处理</h3><blockquote><p>我们在第四种方法中已经尝试了用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组。请看下面的代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方法 6</span><br><span class="line">let arr = [1, [2, [3, [4, 5]]], 6];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  let str = JSON.stringify(arr);</span><br><span class="line">  str = str.replace(/(\[|\])/g, &#x27;&#x27;);</span><br><span class="line">  str = &#x27;[&#x27; + str + &#x27;]&#x27;;</span><br><span class="line">  return JSON.parse(str); </span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/images/20210414170438.png"> </p>]]></content>
    
    
    <summary type="html">实现数组扁平化的六种方式</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="-JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端的优化</title>
    <link href="http://example.com/2021/09/16/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/09/16/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BC%98%E5%8C%96/</id>
    <published>2021-09-16T12:21:07.000Z</published>
    <updated>2022-08-26T02:48:43.880Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、-加载优化（减少http请求数）"><a href="#一、-加载优化（减少http请求数）" class="headerlink" title="一、 加载优化（减少http请求数）"></a>一、 加载优化（减少http请求数）</h3><p>常用的减少http请求数有以下几种：</p><ol><li><p>合并图片：当图片较多时，像精灵图，雪碧图可以合并为一张大图，从而减少http请求数。经常变化的图片可能不太合适，变化相对稳定的就可以考虑。合并大图除了能减少http 请求数外，还可以充分利用缓存来提升性能。</p></li><li><p>合并压缩css样式表和js脚本，他们的共同目的都是为了减少http连接数。</p></li><li><p>去掉不必要的请求，开发写代码或者系统升级之后残留的无效请求连接。</p></li><li><p>首屏加载：首屏快速显示可大大的提升用户对页面速度的感知，应尽量针对首屏的快速显示做出相应的优化。</p></li><li><p>充分利用缓存：来减少向服务器发送的请求数，节省网络资源，所有静态资源都要放在服务器端并设置缓存，并且要尽量使用长缓存。</p></li><li><p>预加载：大型资源页面可使用Loading，资源加载完成后再显示页面，但是加载时间过长，会造成负体验。</p></li><li><p>异步加载第三方资源：第三方资源不可控，会影响页面加载，所以要异步加载第三方资源。</p></li></ol><h3 id="二、图片优化"><a href="#二、图片优化" class="headerlink" title="二、图片优化"></a>二、图片优化</h3><p>优化方法：</p><ol><li><p>尽可能的使用PNG格式的图片，它相对来说体积较小，可以使用工具压缩，在上线之前最好进行一定的优化。</p></li><li><p>同时在代码中进行图片的延迟加载，也叫做赖加载。</p></li><li><p>避免img、iframe等标签的src属性为空：空src会重新加载当前页面，影响速度和效率。</p></li><li><p>图像尽量避免使用DataURL：DataURL图像没有使用图像压缩算法，文件会变大，并且要解码后再渲染，加载慢耗时长。</p></li></ol><h3 id="三、使用CDN"><a href="#三、使用CDN" class="headerlink" title="三、使用CDN"></a>三、使用CDN</h3><p>CDN：实现把内容从中心媒体服务器分发到边缘服务器的网络体系即内容分发网络，CDN具有更低的网络延迟和丢包率，能够分配负载，节省带宽提高网站的性能，可以使用户就近取得所需内容，解决网络拥挤的状况，提高用户访问网站的响应速度。</p><p>如果安全性对你的网站很重要，就不要使用公共的CDN，因为当你远程从CDN请求文件时，你的访问来源信息也被发送过去，一些远程的js文件可能被修改用来搜集你的用户或者系统信息，而当你使用https协议时，能选择的CDN就更加有限。</p><h3 id="四、开启Gzip（代码压缩）"><a href="#四、开启Gzip（代码压缩）" class="headerlink" title="四、开启Gzip（代码压缩）"></a>四、开启Gzip（代码压缩）</h3><p>Gzip即数据压缩，前端生产环境中将js、css、图片等文件进行压缩，通过减少数据传输量减小传输时间，节省服务器网络带宽，提高前端性能。</p><p>压缩时间、流程、说明</p><h3 id="五、样式表和JS文件的优化"><a href="#五、样式表和JS文件的优化" class="headerlink" title="五、样式表和JS文件的优化"></a>五、样式表和JS文件的优化</h3><ol><li><p>头部内联的样式和脚本会阻塞页面的渲染，一般我们会把css样式表文件放到文件的头部使用link引入，这样可以让CSS样式表尽早地完成下载。</p></li><li><p>对应js脚本文件，一般我们把脚本放在尾部并使用异步方式加载，这样可以尽最大限度的减少样式和脚本对页面的阻塞。</p></li></ol><h3 id="六、减少不必要的Cookie"><a href="#六、减少不必要的Cookie" class="headerlink" title="六、减少不必要的Cookie"></a>六、减少不必要的Cookie</h3><p>Cookie存储在客户端，伴随着HTTP请求在浏览器和服务器之间传递，由于cookie在访问对应域名下的资源时都会通过HTTP请求发送到服务器，从而会影响加载速度，所以尽量减少不必要的Cookie。</p><h3 id="七、脚本优化"><a href="#七、脚本优化" class="headerlink" title="七、脚本优化"></a>七、脚本优化</h3><ol><li>复杂动画效果，使用绝对定位让其脱离文档流，避免循环DOM元素，用transform:translate 代替 position left、right…以此来尽量减少回流和重绘。</li></ol><p>2．将脚本往后挪，减少对并发下载的影响。</p><p>3．缓存.length的值：每次.length计算使用一个变量保存值。</p><p>4．尽量使用事件委托：不给每个子节点单独设置事件监听器，而是设置在其父节点上，然后利用冒泡原理设置每个子节点，避免批量绑定事件以此来减少内存消耗和DOM操作。</p><p>5．尽量使用id选择器：id选择器选择元素是最快的，具有唯一性，灵活性和优先性的优点。</p><h3 id="八、前端代码结构的优化"><a href="#八、前端代码结构的优化" class="headerlink" title="八、前端代码结构的优化"></a>八、前端代码结构的优化</h3><p>1．设置Viewport：HTML的viewport可加快页面的渲染。</p><p>2．减少DOM结点：DOM结点太多会影响页面的渲染。</p><p>3．尽量使用css3动画：合理使用requestAnimationFrame动画代替setTimeout。</p><p>4．优化高频事件：scroll、touchmove等事件尽量使用函数防抖节流等进行限制。</p><ol start="5"><li><p>不滥用WEB字体：WEB字体需要下载、解析、重绘当前页面，尽量减少使用。</p></li><li><p>文件命名规则须统一且要有意义，同类型文件归类到相同的文件夹中。</p></li></ol><h3 id="九、SEO优化"><a href="#九、SEO优化" class="headerlink" title="九、SEO优化"></a>九、SEO优化</h3><ol><li><p>标题： 标题字数不要太长，一般写核心的关键词和网站主题相关的内容。</p></li><li><p>描述：描述是整个页面的综合说明，作用和重要性仅次于标题，描述最好能得吸引人一点，带上自己公司的品牌词和电话，并包括目标关键词。</p></li><li><p>关键词：对关键词进行优化，能够让用户在搜索关键词的时候，能够准确的定位到自己要搜索的内容和网站，能够让网站被更多有需要的人看到。</p></li></ol><p>4.网站代码：网站代码尽量精简，节约百度蜘蛛的时候，这一点针对大型网站特别重要。</p>]]></content>
    
    
    <summary type="html">前端的优化策略有哪些</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="-前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="-HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化指标</title>
    <link href="http://example.com/2021/09/13/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E6%A0%87/"/>
    <id>http://example.com/2021/09/13/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E6%A0%87/</id>
    <published>2021-09-13T02:01:23.000Z</published>
    <updated>2022-08-22T09:19:33.470Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>随着业务的不断迭代，项目日渐壮大，为了给用户提供更优的体验，性能优化是前端开发避不开的话题</p></blockquote><p><strong>性能优化的本质</strong> ：在用户输入url到站点完整把整个页面展示出来的过程中，通过各种优化策略和方法，让页面加载更快；在用户使用过程中，让用户的操作响应更及时，有更好的用户体验。主要是从浏览器的加载和渲染两方面入手。</p><h3 id="优化指标"><a href="#优化指标" class="headerlink" title="优化指标"></a>优化指标</h3><ul><li><p>First Paint 首次绘制（FP）这个指标用于记录页面第一次绘制像素的时间，如显示页面背景色。FP不包含默认背景绘制，但包含非默认的背景绘制。</p></li><li><p>First contentful paint 首次内容绘制 (FCP)<br>LCP是指页面开始加载到最大文本块内容或图片显示在页面中的时间。如果 FP 及 FCP 两指标在 2 秒内完成的话我们的页面就算体验优秀。</p></li><li><p>Largest contentful paint 最大内容绘制 (LCP)<br>用于记录视窗内最大的元素绘制的时间，该时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，另外该指标会在用户第一次交互后停止记录。官方推荐的时间区间，在 2.5 秒内表示体验优秀</p></li><li><p>First input delay 首次输入延迟 (FID)<br>首次输入延迟，FID（First Input Delay），记录在 FCP 和 TTI 之间用户首次与页面交互时响应的延迟。<br>Time to Interactive 可交互时间 (TTI)<br>首次可交互时间，TTI（Time to Interactive）。这个指标计算过程略微复杂，它需要满足以下几个条件：<br>从 FCP 指标后开始计算<br>持续 5 秒内无长任务（执行时间超过 50 ms）且无两个以上正在进行中的 GET 请求<br>往前回溯至 5 秒前的最后一个长任务结束的时间<br>对于用户交互（比如点击事件），推荐的响应时间是 100ms 以内。那么为了达成这个目标，推荐在空闲时间里执行任务不超过 50ms（ W3C 也有这样的标准规定），这样能在用户无感知的情况下响应用户的交互，否则就会造成延迟感。</p></li><li><p>Total blocking time 总阻塞时间 (TBT)<br>阻塞总时间，TBT（Total Blocking Time），记录在 FCP 到 TTI 之间所有长任务的阻塞时间总和。</p></li><li><p>Cumulative layout shift 累积布局偏移 (CLS)<br>累计位移偏移，CLS（Cumulative Layout Shift），记录了页面上非预期的位移波动。页面渲染过程中突然插入一张巨大的图片或者说点击了某个按钮突然动态插入了一块内容等等相当影响用户体验的网站。这个指标就是为这种情况而生的，计算方式为：位移影响的面积 * 位移距离。</p></li></ul><h3 id="性能工具"><a href="#性能工具" class="headerlink" title="性能工具"></a>性能工具</h3><p>调试工具和Web API的使用参考：<a href="https://juejin.cn/post/6911472693405548557#heading-21">https://juejin.cn/post/6911472693405548557#heading-21</a><br>工具列表：</p><ul><li>Lighthouse</li><li>PageSpeed Insights</li><li>Chrome DevTools</li><li>Search Console (Core Web Vitals report)</li><li>web.dev’s提供的测量工具</li><li>web-vitals 扩展</li><li>Chrome User Experience Report</li></ul><blockquote><ul><li>我们已经知道了有哪些工具，那么这些工具怎么使用呢？</li><li>首先我们可以使用Lighthouse，在本地进行测量，根据报告给出的一些建议进行优化；</li><li>发布之后，我们可以使用PageSpeed Insights去看下线上的性能情况；</li><li>接着，我们可以使用Chrome User Experience Report API去捞取线上过去28天的数据；</li><li>发现数据有异常，我们可以使用DevTools工具进行具体代码定位分析；</li><li>使用Search Console’s Core Web Vitals report查看网站功能整体情况；</li><li>使用Web Vitals扩展方便的看页面核心指标情况；</li></ul></blockquote><h3 id="优化实践方案"><a href="#优化实践方案" class="headerlink" title="优化实践方案"></a>优化实践方案</h3><blockquote><p>对于前端应用来说，网络耗时、页面加载耗时、脚本执行耗时、渲染耗时等耗时情况会影响用户的等待时长，而 CPU<br>占用、内存占用、本地缓存占用等则可能会导致页面卡顿甚至卡死。<br>因此，性能优化可以分别从耗时和资源占用两方面来解决，也可以理解成时间和空间两个方面。</p></blockquote><h3 id="时间角度"><a href="#时间角度" class="headerlink" title="时间角度"></a>时间角度</h3><p>在时间角度进行优化主要是减少耗时，浏览器在页面加载的过程中，主要会进行以下的步骤：</p><ul><li>网络请求相关（发起 HTTP 请求从服务端获取页面资源，包括 HTML&#x2F;CSS&#x2F;JS&#x2F;图片资源等）</li><li>浏览器解析 HTML 和渲染页面</li><li>加载 Javascript 代码时会暂停页面渲染（包括解析到外部资源，会发起 HTTP 请求获取并加载）</li></ul><h4 id="耗时优化的着手点："><a href="#耗时优化的着手点：" class="headerlink" title="耗时优化的着手点："></a>耗时优化的着手点：</h4><ul><li>网络请求优化</li><li>首屏加载优化</li><li>渲染过程优化</li><li>计算&#x2F;逻辑运行提速</li></ul><h3 id="网络请求优化"><a href="#网络请求优化" class="headerlink" title="网络请求优化"></a>网络请求优化</h3><blockquote><p>目标在于减少网络资源的请求和加载耗时，如果考虑 HTTP 请求过程，显然我们可以从几个角度来进行优化：</p></blockquote><ul><li>请求链路：DNS 查询、部署 CDN 节点、缓存等</li><li>数据大小：代码大小、图片资源等<blockquote><p>对于请求链路，核心的方案常常包括使用缓存，比如 DNS 缓存、CDN 缓存、HTTP 缓存、后台缓存等等，前端的话还可以考虑使用<br>Service Worker、PWA等技术。使用缓存并非万能药，很多使用由于缓存的存在，我们在功能更新修复的时候还需要考虑缓存的情况。除此之外，还可以考虑使用<br>HTTP&#x2F;2、HTTP&#x2F;3 等提升资源请求速度，以及对多个请求进行合并，减少通信次数；对请求进行域名拆分，提升并发请求数量。<br>数据大小则主要考对请求资源进行合理的拆分（CSS、Javascript 脚本、图片&#x2F;音频&#x2F;视频等）和压缩，减少请求资源的体积，比如使用<br>Tree-shaking、代码分割、移除用不上的依赖项等。<br>在请求资源返回后，浏览器会进行解析和加载，这个过程会影响页面的可见时间，通过对首屏加载的优化，可有效地提升用户体验。</p></blockquote></li></ul><h3 id="首屏加载优化"><a href="#首屏加载优化" class="headerlink" title="首屏加载优化"></a>首屏加载优化</h3><p>首屏加载优化核心点在于两部分：</p><ul><li>将页面内容尽快地展示给用户，减少页面白屏时间。</li><li>将用户可操作的时间尽量提前，避免用户无法操作的卡顿体验。<blockquote><p>整体的优化思路包括：尽可能提前页面可见，以及将用户可交互的时间提前。一般来说，我们需要尽可能地降低首屏需要的代码量和执行耗时，可以通过以下方式进行：</p></blockquote></li></ul><blockquote><ul><li>对页面的内容进行分片&#x2F;分屏加载</li><li>仅加载需要的资源，通过异步或是懒加载的方式加载剩余资源</li><li>使用骨架屏进行预渲染</li><li>使用差异化服务，比如读写分离，对于不同场景按需加载所需要的模块</li><li>使用服务端直出渲染，减少页面二次请求和渲染的耗时</li><li>有些时候，我们的页面也需要在客户端进行展示，此时可充分利用客户端的优势：</li><li>配合客户端进行资源预请求和预加载，比如使用预热 Web 容器</li><li>配合客户端将资源和数据进行离线，可用于下一次页面的快速渲染</li><li>使用秒看技术，通过生成预览图片的方式提前将页面内容提供给用户<br>除了首屏渲染以外，用户在浏览器页面过程中，也会触发页面的二次运算和渲染，此时需要进行渲染过程的优化。</li></ul></blockquote><h3 id="渲染过程优化"><a href="#渲染过程优化" class="headerlink" title="渲染过程优化"></a>渲染过程优化</h3><p>渲染过程的优化可以理解成首屏加载完成后，用户的操作交互触发的二次渲染。</p><blockquote><p>主要思路是减少用户的操作等待时间，以及通过将页面渲染帧率保持在 60FPS 左右，提升页面交互和渲染的流畅度。包括但不限于以下方案：</p><ul><li>使用资源预加载，提升空闲时间的资源利用率</li><li>减少&#x2F;合并 DOM 操作，减少浏览器渲染过程中的计算耗时</li><li>使用离屏渲染，在页面不可见的地方提前进行渲染（比如 Canvas 离屏渲染）</li><li>通过合理使用浏览器 GPU 能力，提升浏览器渲染效率（比如使用 css transform 代替 Canvas 缩放绘制）<br>以上这些，是对常见的 Web 页面渲染优化方案。对于运算逻辑复杂、计算量较大的业务逻辑，我们还需要进行计算&#x2F;逻辑运行的提速。</li></ul></blockquote><h3 id="计算-x2F-逻辑运行提速"><a href="#计算-x2F-逻辑运行提速" class="headerlink" title="计算&#x2F;逻辑运行提速"></a>计算&#x2F;逻辑运行提速</h3><blockquote><p>计算&#x2F;逻辑运行速度优化的主要思路是“拆大为小、多路并行”，方式包括但不限于：</p><ul><li>通过将 Javscript 大任务进行拆解，结合异步任务的管理，避免出现长时间计算导致页面卡顿的情况</li><li>将耗时长且非关键逻辑的计算拆离，比如使用 Web Worker</li><li>通过使用运行效率更高的方式，减少计算耗时，比如使用 Webassembly</li><li>通过将计算过程提前，减少计算等待时长，比如使用 AOT 技术</li><li>通过使用更优的算法或是存储结构，提升计算效率，比如 VSCode 使用红黑树优化文本缓冲区的计算</li><li>通过将计算结果缓存的方式，减少运算次数</li></ul></blockquote><h3 id="空间角度"><a href="#空间角度" class="headerlink" title="空间角度"></a>空间角度</h3><p>在做性能优化的时候，其实很多情况下会依赖时间换空间、空间换时间等方式，只能根据自己项目的实际情况做出取舍，选择相对合适的一种方案去进行优化。<br>资源占用常见的优化方式包括：</p><ul><li>合理使用缓存，不滥用用户的缓存资源（比如浏览器缓存、IndexDB），及时进行缓存清理</li><li>避免存在内存泄露，比如尽量避免全局变量的使用、及时解除引用等</li><li>避免复杂&#x2F;异常的递归调用，导致调用栈的溢出</li><li>通过使用数据结构享元的方式，减少对象的创建，从而减少内存占用</li></ul>]]></content>
    
    
    <summary type="html">浅析前端性能优化指标</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="-前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>图片懒加载和预加载的区别</title>
    <link href="http://example.com/2021/08/13/Html/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/08/13/Html/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-08-13T05:53:19.000Z</published>
    <updated>2022-08-15T06:45:13.173Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是懒加载？"><a href="#1-什么是懒加载？" class="headerlink" title="1.什么是懒加载？"></a>1.什么是懒加载？</h3><p>懒加载也就是延迟加载。<br>当访问一个页面的时候，先把img元素或是其他元素的背景图片路径替换成一张大小为1*1px图片的路径（这样就只需请求一次，俗称占<a href="https://so.csdn.net/so/search?q=%E4%BD%8D%E5%9B%BE&spm=1001.2101.3001.7020">位图</a>），只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。这就是图片懒加载。</p><h3 id="2-为什么要使用懒加载？"><a href="#2-为什么要使用懒加载？" class="headerlink" title="2.为什么要使用懒加载？"></a>2.为什么要使用懒加载？</h3><p>很多页面，内容很丰富，页面很长，图片较多。比如说各种商城页面。这些页面图片数量多，而且比较大，少说百来K，多则上兆。要是页面载入就一次性加载完毕。估计大家都会等到黄花变成黄花菜了。</p><h3 id="3-懒加载的原理是什么？"><a href="#3-懒加载的原理是什么？" class="headerlink" title="3.懒加载的原理是什么？"></a>3.懒加载的原理是什么？</h3><p>页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片，只有通过javascript设置了图片路径，浏览器才会发送请求。<br>懒加载的原理就是先在页面中把所有的图片统一使用一张占位图进行占位，把正真的路径存在元素的“data-url”（这个名字起个自己认识好记的就行）属性里，要用的时候就取出来，再设置；</p><h3 id="4-懒加载的实现步骤？"><a href="#4-懒加载的实现步骤？" class="headerlink" title="4.懒加载的实现步骤？"></a>4.懒加载的实现步骤？</h3><p>1)首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。<br>2)页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。<br>3)在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。</p><h3 id="5-懒加载的优点是什么？"><a href="#5-懒加载的优点是什么？" class="headerlink" title="5.懒加载的优点是什么？"></a>5.懒加载的优点是什么？</h3><p>页面加载速度快、可以减轻服务器的压力、节约了流量,用户体验好</p><p>&#x2F;&#x2F;懒加载代码实现<br>var viewHeight &#x3D; document.documentElement.clientHeight &#x2F;&#x2F; 可视区域的高度</p><p>function lazyload () {<br>&#x2F;&#x2F; 获取所有要进行懒加载的图片<br>var eles &#x3D; document.querySelectorAll(‘img[data-original][lazyload]’)<br>Array.prototype.forEach.call(eles, function (item, index) {<br>var rect<br>if (item.dataset.original &#x3D;&#x3D;&#x3D; ‘’)<br>return<br>rect &#x3D; item.getBoundingClientRect()<br>&#x2F;&#x2F; 图片一进入可视区，动态加载<br>if (rect.bottom &gt;&#x3D; 0 &amp;&amp; rect.top &lt; viewHeight) {<br>!function () {<br>var img &#x3D; new Image()<br>img.src &#x3D; item.dataset.original<br>img.onload &#x3D; function () {<br>item.src &#x3D; img.src<br>}<br>item.removeAttribute(‘data-original’)<br>item.removeAttribute(‘lazyload’)<br>}()<br>}<br>})<br>}<br>&#x2F;&#x2F; 首屏要人为的调用，否则刚进入页面不显示图片<br>lazyload()</p><p>document.addEventListener(‘scroll’, lazyload)</p><h3 id="预加载的核心要点如下："><a href="#预加载的核心要点如下：" class="headerlink" title="预加载的核心要点如下："></a>预加载的核心要点如下：</h3><ul><li><p>1.图片等静态资源在使用之前的提前请求；</p></li><li><p>2.资源后续使用时可以从缓存中加载，提升用户体验；</p></li><li><p>3.页面展示的依赖关系维护（必需的资源加载完才可以展示页面，防止白屏等）；</p></li></ul><h4 id="实现预加载主要有三个方法："><a href="#实现预加载主要有三个方法：" class="headerlink" title="实现预加载主要有三个方法："></a>实现预加载主要有三个方法：</h4><p>1.html中img标签最初设置为display:none；</p><p>2.js脚本中使用image对象动态创建好图片；</p><p>3.使用XMLHttpRequest对象可以更加精细的控制预加载过程，缺点是无法跨域：</p><h3 id="1-什么是预加载？"><a href="#1-什么是预加载？" class="headerlink" title="1.什么是预加载？"></a>1.什么是预加载？</h3><p>提前加载图片，当用户需要查看时可直接从本地缓存中渲染</p><h3 id="2-为什么要使用预加载？"><a href="#2-为什么要使用预加载？" class="headerlink" title="2.为什么要使用预加载？"></a>2.为什么要使用预加载？</h3><p>图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。</p><h3 id="3-实现预加载的方法有哪些？"><a href="#3-实现预加载的方法有哪些？" class="headerlink" title="3.实现预加载的方法有哪些？"></a>3.实现预加载的方法有哪些？</h3><p>方法一：用CSS和JavaScript实现预加载<br>方法二：仅使用JavaScript实现预加载<br>方法三：使用Ajax实现预加载</p><h3 id="3、懒加载和预加载的对比"><a href="#3、懒加载和预加载的对比" class="headerlink" title="3、懒加载和预加载的对比"></a>3、懒加载和预加载的对比</h3><p><strong>1)概念</strong>：</p><p>懒加载也叫延迟加载：JS图片延迟加载,延迟加载图片或符合某些条件时才加载某些图片。<br>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</p><p><strong>2)区别：</strong></p><p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p><h4 id="3-懒加载的意义及实现方式有："><a href="#3-懒加载的意义及实现方式有：" class="headerlink" title="3)懒加载的意义及实现方式有："></a>3)懒加载的意义及实现方式有：</h4><p><strong>意义：</strong><br>懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。<br><strong>实现方式：</strong><br>1.第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟.<br>2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。<br>3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。</p><h4 id="4-预加载的意义及实现方式有："><a href="#4-预加载的意义及实现方式有：" class="headerlink" title="4)预加载的意义及实现方式有："></a>4)预加载的意义及实现方式有：</h4><p><strong>意义:</strong><br>预加载可以说是牺牲服务器前端性能，换取更好的用户体验，这样可以使用户的操作得到最快的反映。<br><strong>实现方式：</strong><br>实现预载的方法非常多，比如：用CSS和JavaScript实现预加载；仅使用JavaScript实现预加载；使用Ajax实现预加载。<br>常用的是new Image();设置其src来实现预载，再使用onload方法回调预载完成事件。只要浏览器把图片下载到本地，同样的src就会使用缓存，这是最基本也是最实用的预载方法。当Image下载完图片头后，会得到宽和高，因此可以在预载前得到图片的大小(方法是用记时器轮循宽高变化)。</p><h3 id="4、补充知识"><a href="#4、补充知识" class="headerlink" title="4、补充知识"></a>4、补充知识</h3><h4 id="屏幕可视窗口大小"><a href="#屏幕可视窗口大小" class="headerlink" title="屏幕可视窗口大小"></a>屏幕可视窗口大小</h4><p>原生方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> window.innerHeight 标准浏览器及IE9+ || </span><br><span class="line"></span><br><span class="line"> document.documentElement.clientHeight 标准浏览器及低版本IE标准模式 || </span><br><span class="line"></span><br><span class="line"> document.body.clientHeight  低版本混杂模式 </span><br><span class="line"></span><br><span class="line">jQuery方法：  </span><br><span class="line"></span><br><span class="line">    $(window).height();</span><br></pre></td></tr></table></figure><p>浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离：</p><p>原生方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      window.pagYoffset 标准浏览器及IE9+ || </span><br><span class="line"></span><br><span class="line">      document.documentElement.scrollTop 兼容ie低版本的标准模式 || </span><br><span class="line"></span><br><span class="line">      document.body.scrollTop 兼容混杂模式； </span><br><span class="line"></span><br><span class="line">jQuery方法： </span><br><span class="line"></span><br><span class="line">      $(document).scrollTop()</span><br></pre></td></tr></table></figure><h4 id="获取元素的尺寸"><a href="#获取元素的尺寸" class="headerlink" title="获取元素的尺寸"></a>获取元素的尺寸</h4><p>$(o).width() &#x3D; o.style.width;<br>$(o).innerWidth() &#x3D; o.style.width+o.style.padding;<br>$(o).outerWidth() &#x3D; o.offsetWidth &#x3D; o.style.width+o.style.padding+o.style.border；<br>$(o).outerWidth(true) &#x3D; o.style.width+o.style.padding+o.style.border+o.style.margin；</p><p>注意<br>要使用原生的style.xxx方法获取属性，这个元素必须已经有内嵌的样<br>如果原先是通过外部或内部样式表定义css样式，必须使用o.currentStyle[xxx] || document.defaultView.getComputedStyle(0)[xxx]来获取样式值。</p>]]></content>
    
    
    <summary type="html">图片懒加载和预加载的区别</summary>
    
    
    
    <category term="Html" scheme="http://example.com/categories/Html/"/>
    
    
    <category term="-Html" scheme="http://example.com/tags/Html/"/>
    
  </entry>
  
  <entry>
    <title>eCharts图表自适应</title>
    <link href="http://example.com/2021/07/19/Echarts/%E5%9B%BE%E8%A1%A8%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F/"/>
    <id>http://example.com/2021/07/19/Echarts/%E5%9B%BE%E8%A1%A8%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F/</id>
    <published>2021-07-19T08:12:21.000Z</published>
    <updated>2022-08-22T00:55:32.503Z</updated>
    
    <content type="html"><![CDATA[<h3 id="当一个页面只有一个echarts图形时"><a href="#当一个页面只有一个echarts图形时" class="headerlink" title="当一个页面只有一个echarts图形时"></a>当一个页面只有一个echarts图形时</h3><p><strong>当一个页面只有一个echarts图形时</strong>，可以写为如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myChart.setOption(option);</span><br><span class="line">window.onresize = myChart.resize;</span><br></pre></td></tr></table></figure><h3 id="当一个页面含有多个echarts图形时"><a href="#当一个页面含有多个echarts图形时" class="headerlink" title="当一个页面含有多个echarts图形时"></a>当一个页面含有多个echarts图形时</h3><p><strong>当一个页面含有多个echarts图形时</strong>，可以写成如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myChart.setOption(option);</span><br><span class="line">window.addEventListener(&quot;resize&quot;,function()&#123;</span><br><span class="line">    myChart.resize();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>当页面中包含多个div和echart时，如果写成第一种情况代码时，只有最后一个被画出的图形能自适应屏幕大小，建议全部使用第二种情况。</p></blockquote>]]></content>
    
    
    <summary type="html">eCharts图表自适应大小</summary>
    
    
    
    <category term="eCharts" scheme="http://example.com/categories/eCharts/"/>
    
    
    <category term="-eCharts" scheme="http://example.com/tags/eCharts/"/>
    
  </entry>
  
  <entry>
    <title>css预编译</title>
    <link href="http://example.com/2021/07/02/Css/css%E9%A2%84%E7%BC%96%E8%AF%91/"/>
    <id>http://example.com/2021/07/02/Css/css%E9%A2%84%E7%BC%96%E8%AF%91/</id>
    <published>2021-07-02T02:19:21.000Z</published>
    <updated>2022-08-20T00:17:59.349Z</updated>
    
    <content type="html"><![CDATA[<p>css预编译常用模块 less、sass、stylus</p><h3 id="css预编译解决的问题"><a href="#css预编译解决的问题" class="headerlink" title="css预编译解决的问题"></a>css预编译解决的问题</h3><p><strong>css预编译</strong>：属于css预处理语言的一种，为css赋予了动态语言的特性</p><blockquote><p>例如：可以使用变量、表达式、循环、判断等</p></blockquote><ul><li>less编译的方式：前端编译、node编译、webpack编译</li><li>sass编译的方式：ruby编译、webpack编译</li></ul><h3 id="编译常用方式："><a href="#编译常用方式：" class="headerlink" title="编译常用方式："></a>编译常用方式：</h3><h4 id="嵌套式语法："><a href="#嵌套式语法：" class="headerlink" title="嵌套式语法："></a>嵌套式语法：</h4><p>less,sass都是一样的<br>less的文件后缀是.less。sass的文件后缀是.scss</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.a &#123;</span><br><span class="line">width: 100px;</span><br><span class="line">.b &#123;</span><br><span class="line">width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译过后的css<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.a &#123;</span><br><span class="line">width: 100px;</span><br><span class="line">&#125;</span><br><span class="line">// .a 下的 .b</span><br><span class="line">.a .b &#123;</span><br><span class="line">width: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less: @key:value;</span><br><span class="line">sass: $key:value;</span><br></pre></td></tr></table></figure><h4 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">​在less中定义混合就是一组特定的选择器</span><br><span class="line">​定义： </span><br><span class="line">​.aaaaaa &#123;</span><br><span class="line">​样式</span><br><span class="line">​&#125;</span><br><span class="line">​使用： .b&#123;</span><br><span class="line">​.aaaaaa ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">​在sass中分为两个步骤：</span><br><span class="line">​第一步定义：</span><br><span class="line">​@mixin hunhe &#123;</span><br><span class="line">​样式列表</span><br><span class="line">​……</span><br><span class="line">​&#125;</span><br><span class="line"></span><br><span class="line">​第二步使用：</span><br><span class="line">​@include hunhe</span><br></pre></td></tr></table></figure><h4 id="mixin定义，包含使用"><a href="#mixin定义，包含使用" class="headerlink" title="mixin定义，包含使用"></a>mixin定义，包含使用</h4><p><strong>less</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//  : 后面可以添加默认参数 </span><br><span class="line">.method( @a: 20px, @b: 20px ) &#123;</span><br><span class="line">样式名：   @a；</span><br><span class="line">样式名：   @b;</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">.a &#123;</span><br><span class="line">    .method(100px , 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sass</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//  : 后面可以添加默认参数</span><br><span class="line">@minxin method($a: 20px,  $b ) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">.a &#123;</span><br><span class="line">@include: method(100px , 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插值语法</strong></p><blockquote><p>在less中的插值语法：@{key}<br>在sass中插值语法： #{变量} </p></blockquote><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><p><strong>less</strong><br><strong>sass</strong><br>是因为 sass 比 less晚出来。 会有一些优化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 使用   @if   @else if</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">什么是css预编译</summary>
    
    
    
    <category term="Css" scheme="http://example.com/categories/Css/"/>
    
    
    <category term="-Css" scheme="http://example.com/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>常用的hook</title>
    <link href="http://example.com/2021/06/25/React/%E5%B8%B8%E7%94%A8%E7%9A%84hook/"/>
    <id>http://example.com/2021/06/25/React/%E5%B8%B8%E7%94%A8%E7%9A%84hook/</id>
    <published>2021-06-25T02:50:39.000Z</published>
    <updated>2022-08-10T02:04:09.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p>示例：</p><p>const [stateA, setStateA] &#x3D; useState(0)</p><p>参数是初始state（定义初始state最好给出初始值，方便后期维护， 0&#x2F;false&#x2F;’’&#x2F;[]&#x2F;{}）。</p><p>返回值：一个是当前state，一个是更新state的函数。</p><p>useState的实现很简单，只有两行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export function useState&lt;S&gt;(initialState: (() =&gt; S) | S) &#123;</span><br><span class="line">  const dispatcher = resolveDispatcher();</span><br><span class="line">  return dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点都在dispatcher上，dispatcher通过resolveDispatcher()来获取，这个函数只是将ReactCurrentDispatcher.current的值赋给了dispatcher</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function resolveDispatcher() &#123;</span><br><span class="line">  const dispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">  return dispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useState挂在dispatcher上，resolveDispatcher() 返回的是 ReactCurrentDispatcher.current，所以useState(xxx)等价于ReactCurrentDispatcher.current.useState(xxx)。<br>简单理解：</p><blockquote><p> 初次渲染的时候，按照 useState，useEffect 的顺序，把 state，deps 等按顺序塞到 memoizedState 数组中，共享同一个 memoizedState，共享同一个顺序。<br>更新的时候，按照顺序，从 memoizedState 中把上次记录的值拿出来。</p></blockquote><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>useEffect的实现很简单，也是只有两行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export function useEffect (create: () = &gt;(() = &gt;void) | void, deps: Array &lt; mixed &gt; |void | null, ) : void &#123;</span><br><span class="line">  const dispatcher = resolveDispatcher();</span><br><span class="line">  return dispatcher.useEffect(create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useEffect产生的hook会放在fiber.memoizedState上，调用后生成一个effect对象，存储到对应hook的memoizedState中，与其他effect连接成环形链表。<br>单个的effect对象包含以下几个属性：<br>create：传入useEffect函数的第一个参数，即回调函数；<br>destory：回调函数中的return函数，在改effect销毁的时候执行，默认发生在第一次渲染后，也可以让它在依赖项数组中的值改变时执行，通过return清除副作用函数（如监听、订阅、计时器等）；<br>deps：依赖项，传入的第二个参数，用来控制该Effect包裹的函数执不执行。如果依赖项为空数组[]，则该Effect在每次组件挂载时执行，且仅执行一次，相当于class组件中的componentDidMount和componentDidupdate生命周期的融合；如果没有第二个参数，则effect会不停地调用。<br>next：指向下一个effect；<br>tag：effect的类型，区分useEffect和useLayoputEffect。<br>hook会挂载到fiber.memoizedState上。hook按出现顺序进行存储，memoizedState存储了useEffect的effect对象（effect1），next指向useLayoutEffect的effect对象（effect2），effect2的next又会指向effect1，最终形成闭环。结构如下：<br><img src="https://img-blog.csdnimg.cn/20210524181825618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwOTk3NTAz,size_16,color_FFFFFF,t_70"></p><p>结论：effect在页面完成渲染后按照先后顺序执行，并且内部执行时异步的</p><blockquote><p>useEffect和useLayoutEffect：<br>useLayoutEffect也是一个hook方法，跟useEffect类似，区别在于渲染时机不同，useEffect发生在浏览器渲染结束后执行，useLayoutEffect则是发生在dom更新完成后。</p></blockquote><h4 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h4><p>useLayoutEffect和useEffect很像，唯一的不同点就是useEffect是异步执行，而useLayoutEffect是同步执行的。</p><p>当函数组件刷新（渲染）时，</p><p>包含useEffect的组件整个运行过程如下：<br>1、触发组件重新渲染（通过改变组件state或者组件的父组件重新渲染，导致子节点渲染）<br>2、组件函数执行<br>3、组件渲染后呈现到屏幕上<br>4、useEffect hook执行</p><p>包含useLayoutEffect的组件整个运行过程如下：<br>1、触发组件重新渲染（通过改变组件state或者组件的父组件重新渲染，导致子组件渲染）<br>2、组件函数执行<br>3、useLayoutEffect hook执行, React等待useLayoutEffect的函数执行完毕<br>4、组件渲染后呈现到屏幕上</p><p>useEffect异步执行的优点是，react渲染组件不必等待useEffect函数执行完毕，造成阻塞。</p><p>百分之99的情况，使用useEffect就可以了，唯一需要用到useLayoutEffect的情况就是，在使用useEffect的情况下，我们的屏幕会出现闪烁的情况（组件在很短的时间内渲染了两次）。</p><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p>参数：第一个是reducer纯函数，第二个是初始state，第三个是修改初始state，用于重置<br>返回值是一个数组，数组第一个元素是state的当前值，第二个元素是发送action的dispatch函数</p><blockquote><p>结论：useReducer可以处理多个用useState实现的逻辑（加载状态、错误信息、请求数据）</p></blockquote><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p>参数是创建函数和依赖项数组。</p><p>返回值是一个带有memoized的值，发生在render之前， 并且这个值仅在依赖项改变时才重新计算。</p><blockquote><p>结论：useMemo发生在render前，返回一个缓存的数据，且仅在依赖项改变后变化。</p><p>使用useMemo可以避免多余的计算开销。</p></blockquote><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>参数是内联回调函数和依赖项数组，</p><p>返回值是回调函数的memoized版，该回调函数仅在某个依赖项改变时才会更新。</p><blockquote><p>结论：返回一个缓存的函数，添加依赖项数组可以避免函数的无意义计算，降低了子组件的渲染开销。</p></blockquote><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>返回值是一个可变的ref对象，并且这个对象的值发生改变时不会引起页面的渲染。</p><blockquote><p>结论：useRef可以存储不需要引起页面渲染的数据；修改useRef值的唯一方法是修改.current，且修改后不会引起重渲染。</p></blockquote><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><p>跨组件共享数据的钩子函数，接收一个context对象，并返回该对象的当前值。</p><p>当前的context值由上层组件中距离当前组件最近的&lt;MyContext.Provider&gt;的value决定，并且父组件的context发生改变是，子组件都会重新渲染。</p><blockquote><p>结论：useContext会在context值变化时重新渲染，&lt;MyContext.Provider&gt;的value发生变化时，包裹的组件无论是否订阅value值，都会重新渲染，可以使用memo对未使用value的子组件进行优化。</p></blockquote>]]></content>
    
    
    <summary type="html">React中常用的hook</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="-React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>类组件和函数组件的区别</title>
    <link href="http://example.com/2021/06/25/React/%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/06/25/React/%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-06-25T02:50:39.000Z</published>
    <updated>2022-08-11T06:33:55.166Z</updated>
    
    
    <summary type="html">类组件和函数组件的区别</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="-React" scheme="http://example.com/tags/React/"/>
    
    <category term="-component" scheme="http://example.com/tags/component/"/>
    
  </entry>
  
</feed>
