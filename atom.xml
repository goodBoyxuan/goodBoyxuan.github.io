<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你又来看我啦</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-10T00:43:02.199Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>知非</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/08/10/React/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/"/>
    <id>http://example.com/2022/08/10/React/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/</id>
    <published>2022-08-10T00:43:02.199Z</published>
    <updated>2022-08-10T00:43:02.199Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>基础面试题</title>
    <link href="http://example.com/2022/07/06/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2022/07/06/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-07-06T06:40:34.000Z</published>
    <updated>2022-08-11T08:27:53.588Z</updated>
    
    <content type="html"><![CDATA[<p><strong><strong>Python 面试题</strong></strong> </p><ol><li>什么是python？使用python有什么好处</li></ol><p>答：1、python非常简单，适合阅读。这种这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。</p><p>2、易学。python虽然是用c语言写的，但是它摈弃了c中非常复杂的指针，简化了python的语法。</p><p>3、可移植性——由于它的开源本质，Python已经被移植在许多平台上</p><p>4、、在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。</p><p>5、Python既支持面向过程的函数编程也支持面向对象的抽象编程。</p><p>6、可扩展性和可嵌入性。</p><p>7、丰富的库。</p><p>8、 Python确实是一种十分精彩又强大的语言。</p><p>9、规范的代码。</p><ol start="2"><li>在Python中导入模块中的对象有哪几种方式</li></ol><p>答：import 模块名</p><p>from 模块名 import 功能名</p><p>from 模块名 import *</p><p>import 模块名 as 别名</p><p>from 模块名 import 功能名 as 别名</p><ol start="3"><li>简述List 和tuple 区别</li></ol><p>1、list中是可变的，tuple不可变</p><p>　  所以tuple没有insert, pop,append方法</p><p>2、定义只有一个元素的tuple的时候，必须加逗号，否则不会被认为是tuple，而被识别为括号比如，a &#x3D; (1) 会被识别为数字1，(1,)这样才被识别为一个元组，只有一个元素，数字1</p><p>3、元组可以转列表，但不可以转字典</p><p>不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p><ol start="4"><li>什么是模块？他有什么好处</li></ol><p>说的通俗点：模块就好比是工具包，要想使用这个工具包中的工具(就好比函数)，就需要导入这个模块</p><p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。</p><p>使用模块还可以避免函数名和变量名冲突。每个模块有独立的命名空间，因此相同名字的函数和变量完全可以分别存在不同的模块中，所以，我们自己在编写模块时，不必考虑名字会与其他模块冲突</p><ol start="5"><li>简述try、except语句的用法</li></ol><p>try:</p><p>可能会出现异常的代码块</p><p>except 异常的类型:</p><p>  出现异常以后的处理语句</p><ol start="6"><li>sort和sorted 方法的区别</li></ol><p>Python list内置sort()方法用来排序，也可以用python内置的全局sorted()方法来对可迭代的序列排序生成新的序列。</p><p>list.sort()和sorted()都接受一个参数reverse（True or False）来表示升序或降序排序</p><ol start="7"><li>如何理解面向对象中的封装 继承 和多态</li></ol><p>封装：这是定义类的准则，根据对象的特点，将行为和属性抽象出来，封装到一个类中。</p><p>继承：这是设计类的技巧。父类与子类，主要体现在代码的重用，不需要大量的编写重复代码。</p><p>多态：不同的子类调用相同的父类方法，产生不同的执行结果，可以增加代码的外部灵活度。多态是以继承和重写父类方法为前提的，它是一种调用方法的技巧，不会影响到类的内部设计。</p><ol start="8"><li>列举常见的异常 及出现的场景</li></ol><p>SystemExit　　　　　　　　 　　　解释器请求退出</p><p>AttributeError 　　　　　　　　　　对象没有这个属性</p><p>NameError 　　　　　　　　　　未声明&#x2F;初始化对象 (没有属性)</p><p>IndexError 　　　　　　　　　　序列中没有此索引(index)</p><p>KeyError　　　　　　　　　　　　 映射中没有这个键</p><p>ImportError　　　　　　　　　　 导入模块&#x2F;对象失败</p><p>TypeError　　　　　　　　　　　　 对类型无效的操作</p><p>ValueError 　　　　　　　　　　　　传入无效的参数</p><ol start="9"><li><p>字典、列表、集合有哪些的方法</p></li><li><p>双等（&#x3D;&#x3D;） 和 is 有什么区别</p></li></ol><p> &#x3D;&#x3D;比较操作符：用来比较两个对象是否相等，value做为判断因素；</p><p> is同一性运算符：比较判断两个对象是否相同，id做为判断因素。</p><ol start="11"><li>python都有哪些自带的数据类型</li></ol><p>Python主要内置类型包括数值、序列、映射、类、实例和异常等。<br>数值类型：全局中只有一个（Python在解释器启动的时候，Python会用None类型生成一个None的对象），包括int类型、float类型、complex类型、bool类型。<br>迭代类型：在Python中，迭代类型可以使用循环来进行遍历。<br>序列类型：list（是可变序列，通常用于存放同类项目的集合）、tuple（是不可变序列，通常用于储存异构数据的多项集）、str（在Python中处理文本数据是使用str对象，也称为字符串。字符串是由Unicode码位构成的不可变序列。）、array、range（表示不可变的数字序列，通常用于在for循环中循环指定的次数）、bytes（由单个字节构成的不可变序列）、bytearray（bytes对象的可变对应物）、memoryvie（二进制序列）<br>映射类型：映射对象将具有hash的值映射到任意对象。映射是可变的对象。目前只有一种标准映射，即dictionary。字典的键几乎是任意值，也就是说，包含列表、字典或其他可变类型的值。<br>集合类型：作为一种无序的多项集，集合并不记录元素位置或插入顺序。相应地，集合不支持索引、切片或其他序列类的操作。目前Python有两种内置集合类型：set和frozenset。</p><ol start="12"><li>可变数据类型和不可变类型分别包括那些</li></ol><p><strong><strong>不可变数据类型</strong><strong><strong><strong>：</strong></strong></strong><strong>整型</strong><strong><strong><strong>，</strong></strong></strong><strong>字符串</strong><strong><strong><strong>，</strong></strong></strong><strong>元组</strong></strong></p><p><strong><strong>可变数据类型</strong><strong><strong><strong>：</strong></strong></strong><strong>集合</strong><strong><strong><strong>，</strong></strong></strong><strong>列表</strong><strong><strong><strong>，</strong></strong></strong><strong>字典</strong></strong></p><ol start="13"><li>python 有哪些常见的运算符</li></ol><p>算数运算符+-*&#x2F;%</p><p>逻辑运算符：and or not</p><p>成员运算符:in  not in</p><p>身份运算符:is  is not</p><ol start="14"><li>如何删除一个列表中重复的元素</li></ol><p>直接遍历列表删除</p><p>通过遍历索引删除</p><p>通过遍历创建的切片来删除原列表</p><p>通过递归函数删除</p><p>set()</p><ol start="15"><li>python中pass语句作用是什么</li></ol><p>在编写代码时只写框架思路，具体实现还未编写就可以用 pass 进行占位，使程序不报错，不会进行任何操作。</p><ol start="16"><li>range()函数的作用</li></ol><p>range()函数是一个可迭代对象（类型是对象）</p><p>range(start,stop[,step])</p><p>start：计数从start开始，默认为0</p><p>stop:计数到stop结束，但不包括stop</p><p>step：步长，默认为1，range(10),等价于range(0,10,1)</p><ol start="17"><li>什么是闭包？闭包的特性</li></ol><p>闭包是由函数及其相关的引用环境组合而成的实体(即：闭包&#x3D;函数块+引用环境)。</p><p>如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包</p><ol start="18"><li>python的装饰器是什么</li></ol><p>它们是修改其他函数的功能的函数。有助于让我们的代码更简短；装饰器传入的参数就是一个函数，然后通过实现各种功能来对这个函数的功能进行增强。</p><ol start="19"><li>python深拷贝、浅拷贝和赋值之间有什么区别</li></ol><p>Python中对象的赋值都是进行对象引用（内存地址）传递</p><p>使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用.</p><p>如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝</p><p>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有被拷贝一说</p><p>如果元祖变量只包含原子类型对象，则不能深拷贝</p><ol start="20"><li>.面向对象有哪些特性</li></ol><p>1）继承是从已有类得到继承信息创建新类的过程。提供继承信息的类为父类；得到继承信息的类为子类。</p><p>2）封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。在类中编写的方法就是对实现细节的封装；编写一个类就是对数据和数据操作的封装。</p><p>3）多态性是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。方法重载实现的是编译时的多态性，而方法重写实现的是运行时的多态性，实现多态要做两件事：1. 方法重写；2. 对象造型。</p><p>4）抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。</p><ol start="21"><li>什么是继承？什么是多态</li></ol><p>多态是：一个对象可以被多个其他对象动态调用<br>继承是：一个子类可以继承父类的属性和方法</p><ol start="22"><li>如何获取当前时间并格式化输出</li></ol><p>1、导入time模块</p><p>2、打印时间戳-time.time()</p><p>3、格式化时间戳为本地的时间-time.localtime()</p><p>print(time.strftime(‘%Y-%m-%d %H:%M:%S’,time.localtime(time.time())))</p><ol start="23"><li>普通函数和lambda函数有什么异同点</li></ol><p>它们是相同的类型,因此它们以相同的方式处理。</p><p>唯一的区别是（a）lambda的主体只能由一个表达式组成，其结果是从创建的函数返回的，（b）alambda表达式是一个计算为函数对象的表达式，而adef语句没有值，并创建一个函数对象并将其绑定到一个名称。</p><ol start="24"><li>什么是列表生成式</li></ol><p>用来创建列表 (list) 的表达式就是列表生成式，也被称为列表推导式</p><ol start="25"><li><p>python装饰器的作用</p></li><li><p>python都有哪些内置函数</p></li><li><p>abs() 2. all() chr() dict() eval() filter() format() input() len() print()  reversed() slice()</p></li><li><p>python的生成器是什么</p></li></ol><p>Python 中还有一种函数，用关键字 yield 来返回值，这种函数叫生成器函数，函数被调用时会返回一个生成器对象，生成器本质上还是一个迭代器</p><ol start="28"><li>python的迭代器是什么</li></ol><p>迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><ol start="29"><li>什么是类方法、静态方法和实例方法</li></ol><p>其中类方法需要使用@classmethod装饰器<br>静态方法需要使用@staticmethod装饰器</p><p>类方法参数cls，实例方法参数self，静态方法相当于寄存在这个类中的方法。</p><ol start="30"><li>读写文件常用的方法有哪些</li></ol><table><thead><tr><th>f.read()</th><th>读取文件中所有内容</th></tr></thead><tbody><tr><td>f.readline()</td><td>读取第一行的内容</td></tr><tr><td>f.readlines()</td><td>读取文件里面所有内容，把每行的内容放到一个list里面</td></tr></tbody></table><p>with open ： 用完后自动关闭文件，省去了手动添加f.close()功能</p><ol start="31"><li>Linux 开机启动过程</li></ol><p>· 加载BIOS(Basic Input Output System)：BIOS是系统启动时加载的第一个软件。</p><p>o 启动上电自检POST(Power-On-Self-Test)，负责完成对CPU、主板、内存、软硬盘子系统、显示子系统（包括显示缓存）、串并行接口、键盘、CD-ROM光驱等的检测，主要检查硬件的好坏。</p><p>o 对外部设备进行初始化，读取BIOS参数，并和实际的硬件进行比较，如果不符合，会影响系统启动。</p><p>o 查找MBR(Master Boot Record,主引导分区)。如果未找到，会提示找不到硬盘。</p><p>· 读取主引导分区(MBR):拷贝启动引导代码BootLoader</p><p>· 启动引导代码(bootloader):当我们的硬盘上有多个操作系统时，可以用来选择进入到哪个操作系统。</p><p>· 加载内核，进入操作系统：运行第一个程序 : &#x2F;sbin&#x2F;init</p><p>o sbin&#x2F;init 会读取相关的配置文件，来确定系统的运行级别。</p><p>§ 0： 关机</p><p>§ 1 ： 单用户模式</p><p>§ 2 ： 无网络支持的多用户模式</p><p>§ 3 ： 有网络支持的多用户模式</p><p>§ 4 ： 保留，未使用</p><p>§ 5 ： 有网络支持，且有图形化界面的多用户模式</p><p>§ 6 ： 重启</p><p>§ 切换运行级别： init 级别</p><p>o 根据对应的运行级别，查找对应的脚本文件。例如，运行5级别，查找 &#x2F;etc&#x2F;rc5.d目录，启动该目录下的相关服务。</p><p>§ 这些文件夹下的init脚本都有一些特别的名字，命名都以S（start）、K（kill）或D（disable）开头，后面跟一个数字。当init进入一个运行等级的时候，它会按照数字顺序运行所有以K开头的脚本并传入stop参数，除非对应的init脚本在前一个运行等级中没有启动。然后init按照数字顺序运行所有以S开头的脚本并传入start参数。任何以D开头的init脚本都会被忽略—这让你可以在指定的运行等级禁止一个脚本，或者你也可以仅仅移除全部符号链接。</p><p>o 解析用户自定义的启动脚本：&#x2F;etc&#x2F;rc.local（如果存在的话）</p><p>o 进入用户界面。</p><ol start="32"><li>Linux 的目录结构是怎样的</li></ol><p><img src="/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/32-1.png" alt="img"> </p><p><img src="/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/32-2.png" alt="img"> </p><ol start="33"><li>什么是硬链接和软链接</li></ol><p>软链接：ln -s 源文件 目标文件<br>硬链接：ln 源文件 目标文件<br>源文件：即你要对谁建立链接</p><p>区别: 软链接文件的大小和创建时间和源文件不同。软链接文件只是维持了从软链接到源文件的指向关系（从jys.soft-&gt;jys可以看出），不是源文件的内容，大小不一样容易理解。<br>硬链接文件和源文件的大小和创建时间一样。硬链接文件的内容和源文件的内容一模一样，相当于copy了一份。</p><ol start="34"><li>如何查看系统都开启了哪些端口</li></ol><p>netstat:用来监听网络连接状态。</p><p>ps</p><p>作用：查看进程信息</p><p>使用：</p><p>ps -ef</p><p>ps aux</p><p>说明：经常在查询进程号的时候结合grep进行过滤</p><p>pstree</p><p>作用：使用树形结构查看进程信息。</p><p>kill</p><p>作用：杀死进程</p><p>示例：kill -9 PID</p><p>说明：强制杀死指定进程</p><ol start="35"><li>使用free查看内存使用情况时，哪个数值表示真正可用的内存量</li></ol><p>· Total（全部） : 1026740</p><p>· Used（已用） : 843396</p><p>· Free（可用） : 183344</p><p>· Shared（共享） : 0</p><p>· Buffers（块设备缓存区） : 52704</p><p>· Cached（文件缓存） : 376384</p><p><strong><strong>Django面试题</strong></strong></p><ol><li>什么是http协议</li></ol><p>http(Hypertext transfer protocol)超文本传输协议，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。也就是说，http协议规定了超文本传输所要遵守的规则。</p><ol start="2"><li>http请求报文组成</li></ol><p>1）请求方法URI协议&#x2F;版本 </p><p>2）请求头(Request Header) </p><p>3）请求正文</p><ol start="3"><li>http响应报文组成</li></ol><p>1）状态行</p><p>2）响应头</p><p>3）响应正文</p><ol start="4"><li>https协议和http的区别</li></ol><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>　　为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><ol start="5"><li>说一下对对端口的理解</li></ol><p>可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指 计算机内部 或 交换机 路由器内的端口，不可见。例如计算机中的80端口、21端口、23端口等。物理端口又称为接口，是可见端口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口都属于物理端口。</p><ol start="6"><li>说一下对django 的认识</li></ol><p>#1.Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。</p><p>#2.Django内置的ORM跟框架内的其他模块耦合程度高。</p><p>#应用程序必须使用Django内置的ORM，否则就不能享受到框架内提供的种种基于其ORM的便利；</p><p>#理论上可以切换掉其ORM模块，但这就相当于要把装修完毕的房子拆除重新装修，倒不如一开始就去毛胚房做全新的装修。</p><p>#3.Django的卖点是超高的开发效率，其性能扩展有限；采用Django的项目，在流量达到一定规模后，都需要对其进行重构，才能满足性能的要求。</p><p>#4.Django适用的是中小型的网站，或者是作为大型网站快速实现产品雏形的工具。</p><p>#5.Django模板的设计哲学是彻底的将代码、样式分离； Django从根本上杜绝在模板中进行编码、处理数据的可能。</p><ol start="7"><li>什么是mtv</li></ol><p>Model(模型)： 负责业务对象与数据库的对象(ORM)。</p><p>Template(模板)：负责如何把页面展示给用户。</p><p>View(视图)：负责业务逻辑，并在适当的时候调用Model和Template。</p><ol start="8"><li>什么是wsgi</li></ol><p>WSGI是一套接口标准协议&#x2F;规范；</p><p>通信（作用）区间是Web服务器和Python Web应用程序之间；</p><p>目的是制定标准，以保证不同Web服务器可以和不同的Python程序之间相互通信</p><ol start="9"><li>django请求的生命周期</li></ol><p>Django的请求生命周期是指当用户在浏览器上输入url到用户看到网页的这个时间段内,Django后台所发生的事情</p><ol><li><p>当用户在浏览器中输入url时,浏览器会生成请求头和请求体发给服务端 请求头和请求体中会包含浏览器的动作(action),这个动作通常为get或者post,体现在url之中.</p></li><li><p>url经过Django中的wsgi,再经过Django的中间件,最后url到过路由映射表,在路由中一条一条进行匹配, 一旦其中一条匹配成功就执行对应的视图函数,后面的路由就不再继续匹配了. </p></li><li><p>视图函数根据客户端的请求查询相应的数据.返回给Django,然后Django把客户端想要的数据做为一个字符串返回给客户端. </p></li><li><p>客户端浏览器接收到返回的数据,经过渲染后显示给用户.</p></li><li><p>简述什么是FBV和CBV</p></li></ol><p>一个url对应一个视图函数,这个模式叫做FBV(Function Base Views)</p><p>另外一种模式叫做CBV(Class Base views),即一个url对应一个类</p><ol start="11"><li>什么是orm</li></ol><p>对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。<br>简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。<br>ORM在业务逻辑层和数据库层之间充当了桥梁的作用。</p><ol start="12"><li>Orm和原生slq的优缺点</li></ol><p>作用：帮助我们封装一下对数据库的操作，避免了我们写不太好维护的SQL的代码<br>优点：比较好维护，不用写那些复杂的sql语句<br>缺点：失去SQL的灵活性，并且越是通用的ORM框架，对性能的消耗就越大</p><ol start="13"><li><p>列举django orm 中常用的方法</p></li><li><p>models.Book.objects.all()  # 获取到所有的书籍对象,结果是对象列表</p></li><li><p>models.Book.objects.get(条件)  # 获取符合条件的对象</p></li><li><p>models.Book.objects.filter(条件)  # 筛选所有符合条件的,结果是对象列表</p></li><li><p>models.Book.objects.all().values( )  # 字典列表,[ {id:1,name:20} , {id:2,name:18} ]</p></li></ol><p>​    values(‘id’)括号内不指定时显示全部,如指定则只显示指定的,[ {id:1} , {id:2,} ]</p><pre><code>6. models.Book.objects.all().values_list( )  # 元组列表,[ (1,20) , (2,18) ]同上,指定时显示指定内容</code></pre><ol start="7"><li>models.Book.objects.all().count()  # 计数,可统计结果个数,如对Queryset内元素数进行统计.</li></ol><pre><code>8. models.Book.objects.all().first()  # 获取结果中的第一条,即使前面结果列表为空,也不会报错9. models.Book.objects.filter().last()  # 获取结果中的最后一条</code></pre><p>  13.models.Book.objects.filter().exists()  # 判断Queryset列表是否有东西,结果为True或False; </p><ol start="14"><li>class Meta中的元信息字段有哪些</li></ol><p>Abstract  app_label   db_table   default_related_name   managed</p><ol start="15"><li>Orm 操作values和values_list的区别</li></ol><p>values()的结果得到的是一个字典形式的查询集QuerySet，查询集是一个可迭代对象</p><p>values_list()返回的是列表元组</p><ol start="16"><li>什么是Cookie、如何获取、设置Cookie</li></ol><p>cookie：存储数据，当用户访问了某个网站（网页）的时候，我们就通过cookie来向访问者电脑上存储数据</p><p>设置： response.set_cookie(‘my_cookie’,’cookie value’)</p><p>获取：value &#x3D; request.COOKIES[“cookie_key”]</p><ol start="17"><li>cookie和session的区别</li></ol><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上.</p><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</p><p>3、设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。<br>4、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。<br>5、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)</p><p>18.django的Model中的ForeignKey字段中的on_delete参数有什么作用</p><p>on_delete有6个可选值，分别是：</p><p>CASCADE    删除级联，当父表的记录删除时，子表中与其相关联的记录也会删除。即：当一个老师被删除时，关联该老师的学生也会被删除。</p><p>PROTECT    子表记录所关联的父表记录被删除时，会报ProtectedError异常。即：当一个学生所关联的老师被删除时，会报ProtectedError异常。</p><p>SET_NULL    子表记录所关联的父表记录被删除时，将子表记录中的关联字段设为NULL，注意：需要允许数据表的该字段为NULL。</p><p>SET_DEFAULT    子表记录所关联的父表记录被删除时，将子表记录中的关联字段设为一个给定的默认值。</p><p>DO_NOTHING    子表记录所关联的父表记录被删除时，什么也不做。</p><p>“SET”()    设置为一个传递给“SET”()的值或者一个回调函数的返回值，该参数用得相对较少。</p><ol start="19"><li>django中csrf的实现机制</li></ol><p>django为用户实现防止跨站请求伪造的功能，通过中间件 “django.middleware.csrf.CsrfViewMiddleware” 来完成。而对于django中设置防跨站请求伪造功能有分为全局和局部。</p><p>1）启用中间件<br>2）post请求<br>3）验证码<br>4）表单中添加“{”% csrf_token%“}”标签</p><ol start="20"><li>命令makemigrations和migrate的区别</li></ol><p>makemigrations：将模型的更改生成迁移脚本文件。</p><p>migrate：将新生成的迁移脚本，映射到数据库中，创建新的表或者修改表的结构。</p><ol start="21"><li>视图函数中，接收的请求对象常用方法和属性有哪些</li></ol><p>COOKIES,FILES,POST,GET,method</p><ol start="22"><li>HTTP响应常见状态码分类</li></ol><p>200 OK：表示从客户端发送给服务器的请求被正常处理并返回；</p><p>400 Bad Request：表示请求报文中存在语法错误；</p><p>401 Unauthorized：未经许可，需要通过HTTP认证；</p><p>403 Forbidden：服务器拒绝该次访问（访问权限出现问题）</p><p>404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</p><p>500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；</p><ol start="23"><li>在Django中，服务端给客户端响应信息有几种方式？分别是什么</li></ol><p>HTTPresponse，<br>jsonresponse,<br>redirect</p><ol start="24"><li>路由匹配原则是什么</li></ol><p>path不支持正则匹配</p><p>re_path支持正则匹配</p><p>include引用头文件</p><ol start="25"><li>解决跨域的常用方式是什么</li></ol><p>pip install django-cors-headers</p><p>在项目的settings.py文件配置</p><p>注册应用</p><p>INSTALLED_APPS  &#x3D;  [ </p><p>  …</p><p>  ‘corsheaders’ ，</p><p>  …</p><p>]</p><p>注册中间件</p><p>MIDDLEWARE  &#x3D;  [</p><p>  … </p><p>  ‘corsheaders.middleware.CorsMiddleware’ ,  # 注册中间件</p><p>  ‘django.middleware.common.CommonMiddleware’ ，</p><p>  … </p><p>]</p><p>设置允许的来源</p><h1 id="允许全部来源"><a href="#允许全部来源" class="headerlink" title="允许全部来源"></a>允许全部来源</h1><p>CORS_ORIGIN_ALLOW_ALL  &#x3D; True  # 如果为True，将不使用白名单，并且将接受所有来源。默认为False。</p><h1 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h1><p>CORS_ORIGIN_WHITELIST  &#x3D;  [</p><p>  “<a href="https://example.com&quot;/">https://example.com&quot;</a>,</p><p>  “<a href="https://sub.example.com&quot;/">https://sub.example.com&quot;</a>,</p><p>  “http：&#x2F;&#x2F; localhost：8080”,</p><p>  “<a href="http://127.0.0.1:9000&quot;">http://127.0.0.1:9000&quot;</a></p><p>]</p><ol start="26"><li>get请求和post请求的区别</li></ol><p>POST和GET是HTTP协议定义的与服务器交互的方法。GET一般用于获取&#x2F;查询资源信息，而POST一般用于更新资源信息</p><p>1.post是取web页面中提交的值</p><p>2.get是从数据库中取值</p><p>GET是通过URL传给服务器的,POST是通过HTTP头传给服务器的，post的数据是不跟在请求的url后，而是在http头中，get是在url中</p><ol start="27"><li>QueryDict和dict区别</li></ol><p>Querydict ：可以一键对应多个值</p><p>dict ：只能一键对应一个值</p><ol start="28"><li>列举Http请求中常见的请求方式</li></ol><p>POST,GET,PUT,DELETE,TRACCE</p><ol start="29"><li>谈谈你对restful规范的认识</li></ol><p>（1） 每一个URL代表一种资源<br>（2） 客户端与服务器之间，传递这种资源的某种表现层<br>（3） 客户端通过 4 个HTTP动词，对服务器端资源进行操作，实现“表现层状态转化”</p><ol start="30"><li>Django 本身提供了 runserver，为什么不能用来部署</li></ol><p>runserver 方法是调试 Django 时经常用到的运行方式，它使用 Django 自带的</p><p><strong><strong>Js面试题</strong></strong></p><ol><li>说一下从输入URL到页面加载完中间发生了什么</li></ol><p>1、DNS域名解析 2、发起TCP连接（三次握手）  3、发送HTTP请求，接受HTTP响应     4、断开TCP连接（四次挥手）  5、浏览器解析HTML代码，请求js，css等资源，最后进行页面渲染，呈现给用户</p><ol start="2"><li>说一下js数据类型有哪些？</li></ol><p>1.字符串 string</p><p>2.数字    Number</p><p>3.布尔    Boolean</p><p>4.空      null</p><p>5.未定义的 undefined</p><p>6.对象    object</p><p> 对象包括（array数组   json  function 函数 日期 数字对象等）</p><ol start="3"><li>解释 JavaScript 中“undefined”和“not defined”之间的区别</li></ol><p>undefined是javascript语言中定义的五个原始类中的一个，换句话说，undefined并不是程序报错，而是程序允许的一个值。<br>not defined是javascript在运行我们的javascript代码时，遇到没有定义就用来运算的变量时爆出来的错误。</p><ol start="4"><li><p>请描述值类型(基本数据类型)和引用类型的区别</p></li><li><p>值类型：String(字符串)，Number（数字），Boolean(布尔类型),Undefinde<br>2.引用类型：Array(数组)，Object(对象)，Function(函数)</p></li></ol><p>储存方式不一样：值类型是栈存储，引用类型是堆存储</p><p>变量赋值：基本数据类型是直接把值赋给变量。而引用类型是，把值的地址复制给新变量，通过地址再找到内容。</p><ol start="5"><li>说一下JS作用域</li></ol><p>作用域就是变量与函数的可访问范围，即作用域控制着函数与变量的可见性和生命周期</p><p>1.全局作用域</p><p>任何地方都能访问到的对象拥有全局作用域</p><p>1.1.函数外面定义的变量拥有全局作用域，全局变量拥有全局作用域，网页中所有脚本和函数均可使用。全局变量在页面关闭后销毁</p><p>1.2.未定义直接赋值的变量自动声明为全局变量拥有全局作用域</p><p>1.3.window对象的属性拥有全局作用域</p><p>HTML中，全局变量是window对象，所有数据变量都属于window对象</p><p>2.局部作用域</p><p>局部作用域一般只在固定的代码片段内能访问到，最常见的例如函数内部，所以也称为函数作用域</p><p>变量在函数内声明，变量为局部作用域</p><p>局部变量：只能在函数内访问</p><p>ES6的块级作用域</p><p>ES6引入了块级作用域，明确允许在块级作用域中申明函数，let和const命令都涉及块级作用域</p><p>块级作用域允许声明函数只在使用大括号的情况下成立，如果未使用大括号报错</p><ol start="6"><li>什么是 JavaScript 中的提升操作</li></ol><p>:用var声明的变量提升,其只是变量提升了，而没有进行赋值的提升</p><ol start="7"><li>什么是JavaScript原型，原型链 ? 有什么特点？</li></ol><p>JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象，当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p><p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法</p><p>在对象实例和它的构造器之间建立一个链接（它是__proto____属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法</p><ol start="8"><li>如何判断数组</li></ol><p>通过es6 Array.isArrray()做判断</p><p>通过instanceof做判断</p><ol start="9"><li>说一下JS数组常用方法</li></ol><p>Array.map()  Array.forEach()  Array.filter()  Array.every()  Array.some()  Array.push()  Array.pop()  Array.shift()  Array.unshift()</p><ol start="10"><li>说一下字符串操作的常用方法</li></ol><p>slice方法、substring方法</p><ol start="11"><li><p>说一下JS原生常用dom操作方法</p></li><li><p>浏览器是如何渲染页面的</p></li></ol><p>1.根据html文件构建DOM树和CSSOM树。构建DOM树期间，如果遇到JS，阻塞DOM树及CSSOM树的构建，优先加载JS文件，加载完毕，再继续构建DOM树及CSSOM树。</p><p>2.构建渲染树（Render Tree）。</p><p>3.页面的重绘（repaint）与重排（reflow，也有称回流）。页面渲染完成后，若JS操作了DOM节点，根据JS对DOM操作动作的大小，浏览器对页面进行重绘或是重排。</p><ol start="13"><li>简述同步与异步的区别</li></ol><p>同步就相当于是 当客户端发送请求给服务端，在等待服务端响应的请求时，客户端不做其他的事情。当服务端做完了才返回到客户端。这样的话客户端需要一直等待。用户使用起来会有不友好。</p><p>异步就是，当客户端发送给服务端请求时，在等待服务端响应的时候，客户端可以做其他的事情，这样节约了时间，提高了效率。</p><ol start="14"><li>什么是promise</li></ol><p>一.Promise是异步编程的一种解决方案，它是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p><p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同</p><p>样的方法进行处理。promise对象是一个构造函数，用来生成Promise实例；</p><p>二.promise的两个特点  对象状态不受外界影响 &amp;&amp; 一旦状态改变，就不会再变，任何时候都可以得到结果（pending状态–&gt;fulfilled || pending–&gt;rejected）</p><ol start="15"><li><p>async&#x2F;await是什么</p></li><li><p>Async—声明⼀个异步函数(async function someName(){…})</p></li><li><p>⾃动将常规函数转换成Promise，返回值也是⼀个Promise对象</p></li><li><p>只有async函数内部的异步操作执⾏完，才会执⾏then⽅法指定的回调函数</p></li><li><p>异步函数内部可以使⽤await</p></li><li><p>Await—暂停异步的功能执⾏(var result &#x3D; await someAsyncCall();)</p></li><li><p>放置在Promise调⽤之前，await强制其他代码等待，直到Promise完成并返回结果</p></li><li><p>只能与Promise⼀起使⽤，不适⽤与回调</p></li><li><p>只能在async函数内部使⽤</p></li><li><p>箭头函数的this指向哪里</p></li></ol><p>1.在全局环境下，this 始终指向全局对象（window）</p><p>2.对象内部方法的this指向调用这些方法的对象，函数的定义位置不影响其this指向，this指向只和调用函数的对象有关。</p><p>多层嵌套的对象，内部方法的this指向离被调用函数最近的对象（window也是对象，其内部对象调用方法的this指向内部对象， 而非window）。</p><p>3.构造函数中的this与被创建的新对象绑定。</p><ol start="17"><li>null与undefined的区别是什么</li></ol><p>null表示”没有对象”，即该处不应该有值。</p><p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p><ol start="18"><li>说一下 call,apply,bind区别</li></ol><p>　1）apply，call和bind都是 用来改变this的指向</p><p>　2）apply和call会让当前函数立即执行，而bind会返回一个函数，后续需要的时候再调用执行</p><ol start="19"><li>说一下你对JS面向对象的理解</li></ol><p>但JS中对象与纯面向对象语言中的对象是不同的，ECMA标准定义JS中对象：无序属性的集合，其属性可以包含基本值、对象或者函数。可以简单理解为JS的对象是一组无序的值，其中的属性或方法都有一个名字，根据这个名字可以访问相映射的值（值可以是基本值&#x2F;对象&#x2F;方法）。</p><ol start="20"><li>说一下ES6新增特性</li></ol><p>第七种数据类型Symbol</p><p>Symbol用法很强大普遍，es5私有api中已经有很多的使用，例如：常用的String.prototype.split()。</p><p>Symbol创建的值唯一。</p><p>替代传统的常量定义保证唯一并且不被串改将是非常友好的。</p><p>定义私有属性将会非常方便。</p><p>1、let关键字，用来代替 var的关键字，特点： 1、变量不允许被重复定义 2、不会进行变量声明提升 3、保留块级作用域中i的</p><p>2、const定义常量，特点：1、常量值不允许被改变 2、不会进行变量声明提升</p><p>字符串模板&#96;&#96;</p><ol start="21"><li>谈谈你对原型链的理解</li></ol><p>访问一个对象属性时，先在自身属性中查找，找到返回</p><p>如果没有，再沿着__proto__这条链向上查找，找到返回</p><p>如果最终没有找到，返回undefined</p><ol start="22"><li>如何阻止事件冒泡</li></ol><p>Event.stoppropagation()</p><ol start="23"><li>如何阻止默认事件</li></ol><p>event.preventDefault();</p><ol start="24"><li>什么是ajax？ajax作用是什么</li></ol><p>AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。</p><p>通过 AJAX  可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据。</p><p>AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。</p><p>可以无需刷新页面而与服务器端进行通信。</p><p>允许你根据用户事件来更新部分页面内容。</p><ol start="25"><li>原生js ajax请求有几个步骤？分别是什么</li></ol><p>a.创建 XMLHttpRequest对象</p><p>var ajax &#x3D; new XMLHttpRequest()</p><p>b.规定请求的类型、URL 以及是否异步处理请求</p><p>ajax.open(‘GET’,url,true)</p><p>c.发送信息至服务器时内容编码类型</p><p>ajax.setRequestHeader(“Content-type”,“application&#x2F;x-www-form-urlencoded”)</p><p>d.发送请求</p><p>ajax.send(null);</p><p>e.接受服务器响应数据</p><p>ajax.onreadystatechange &#x3D; function () {if (obj.readyState &#x3D;&#x3D; 4 &amp;&amp; (obj.status &#x3D;&#x3D; 200 || obj.status &#x3D;&#x3D; 304)){}”}</p><ol start="26"><li>json字符串转换集json对象、json对象转换json字符串</li></ol><p>JSON.parse()方法,   JSON.stringify()方法</p><ol start="27"><li>什么是JSON</li></ol><p>一种轻量级的数据交互格式。json就是一种在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互。</p><ol start="28"><li>什么情况造成跨域</li></ol><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p><p>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？</p><p>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p><p>由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p><ol start="29"><li>http常见状态码有哪些</li></ol><p>200 OK：表示从客户端发送给服务器的请求被正常处理并返回；</p><p>400 Bad Request：表示请求报文中存在语法错误；</p><p>401 Unauthorized：未经许可，需要通过HTTP认证；</p><p>403 Forbidden：服务器拒绝该次访问（访问权限出现问题）</p><p>404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</p><p>500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；</p><ol start="30"><li>说一下同源策略</li></ol><p><strong><strong>Vue面试题</strong></strong></p><ol><li>MVC、MVP与MVVM模式</li></ol><p>MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式： [1]</p><p>Model（模型）表示应用程序核心（如数据库）。</p><p>View（视图）显示效果（HTML页面）。</p><p>Controller（控制器）处理输入（业务逻辑）。</p><p>MVP 是从经典的模式MVC演变而来，它们的基本思想有相通的地方Controller&#x2F;Presenter负责逻辑的处理，Model提供数据，View负责显示。</p><p>MVVM是Model-View-ViewModel的简写</p><p>· 模型</p><p>·  模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。</p><p>· 视图</p><p>·  就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。</p><p>· 视图模型</p><p>·  视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。</p><ol start="2"><li>vue.js的两个核心是什么</li></ol><p>数据驱动：ViewModel，保证数据和视图的一致性。</p><p>组件系统：应用类UI可以看作全部是由组件树构成的。</p><ol start="3"><li>什么是虚拟dom</li></ol><p>virtual DOM 虚拟DOM，用普通js对象来描述DOM结构，因为不是真实DOM，所以称之为虚拟DOM。这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示 dom 树及其层级结构，那么每次 dom 的更改就变成了对 js 对象的属性的增删改查，这样一来查找 js 对象的属性变化要比查询 dom 树的性能开销小。</p><ol start="4"><li>Real DOM与 Virtual DOM 的区别</li></ol><p>虚拟DOM不会进行排版与重绘操作，而真实DOM会频繁重排与重绘</p><p>虚拟DOM的总损耗是“虚拟DOM增删改+真实DOM差异增删改+排版与重绘”，真实DOM的总损耗是“真实DOM完全增删改+排版与重绘”</p><ol start="5"><li><p>什么是diff算法</p></li><li><p>请详细说下你对vue生命周期的理解</p></li></ol><p>Vue 实例有一个完整的生命周期，也就是从 开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p><ol start="7"><li>第一次页面加载会触发哪几个钩子</li></ol><p><img src="/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/vue-7.png" alt="img"> </p><ol start="8"><li>什么是vue路由</li></ol><p>后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源，这个对应关系就是后端中的路由；</p><p>前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；</p><p>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；</p><ol start="9"><li>vue路由的优点以及缺点是什么</li></ol><p>优点：</p><p>　　用户体验好，不需要每次都从服务器全部获取，快速展现给用户</p><p>缺点：</p><p>不利于 SEO</p><p>使用浏览器的前进，后退键的时候会重新发送请求，没有合理利用缓存</p><p>单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置</p><ol start="10"><li>怎么定义 vue-router 的动态路由?如何获取动态路由传过来的值</li></ol><p>可以通过query，param两种方式<br>区别：query通过url传参，刷新页面还在；params属性页面不在</p><p>params的类型：</p><p>配置路由格式:&#x2F;router&#x2F;:id</p><p>传递的方式：在path后面跟上对应的值</p><p>传递后形成的路径：&#x2F;router&#x2F;123</p><p>query的类类型</p><p>配置路由格式:&#x2F;router,也就是普通配置</p><p>传递的方式:对象中使用query的key作为传递方式</p><p>传递后形成的路径:&#x2F;route?id&#x3D;123</p><ol start="11"><li>请描述vue-router路由守卫的作用？</li></ol><p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。</p><ol start="12"><li>路由守卫钩子函数里面的三个参数分别是什么</li></ol><p>to: Route: 即将要进入的目标 <a href="#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1">路由对象</a></p><p>from: Route: 当前导航正要离开的路由</p><p>next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</p><p>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</p><ol start="13"><li>路由守卫的解析流程</li></ol><p>1 导航被触发。</p><p>2 在失活的组件里调用离开守卫。</p><p>3 调用全局的 beforeEach 守卫。</p><p>4 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</p><p>5 在路由配置里调用 beforeEnter。</p><p>6 解析异步路由组件。</p><p>7 在被激活的组件里调用 beforeRouteEnter。</p><p>8 调用全局的 beforeResolve 守卫 (2.5+)。</p><p>9 导航被确认。</p><p>10 调用全局的 afterEach 钩子。</p><p>11 触发 DOM 更新。</p><p>12 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</p><ol start="14"><li>vue-router路由传参的方式一共有几种？他们是如何就收传递过来的参数</li></ol><p>this.$router.push</p><p>router.replace(…)</p><ol start="15"><li>什么是计算属性</li></ol><p>通常我们会在模板中绑定表达式，模板是用来描述视图结构的。<br>如果模板中的表达式存在过多逻辑，模板会变得臃肿不堪，维护变得非常困难。<br>因此为了简化逻辑，当某个属性的值依赖于其他属性的值时，我们可以使用计算属性。</p><p>计算属性就是当其依赖属性的值发生变化时，这个属性的值会自动更新，与之相关的 DOM 部分也会同步自动更新</p><ol start="16"><li>组件全局注册和局部注册的区别</li></ol><p>全局注册是在main.js中去注册组件，这样在所有子组件中就可以使用了</p><p>局部注册在components文件夹下的的vue文件中的components属性下去注册组件，这样局部注册的组件在其子组件中不可用</p><ol start="17"><li>请你说一下你对vue组件通信的理解</li></ol><p>父传子，子传父，兄弟组件</p><ol start="18"><li>子组件如何与父组件进行通信</li></ol><p>在父组件渲染时  绑定一个自定义事件：</p><p>&lt;List @sj&#x3D;”fn” &#x2F;&gt;  自定义事件的名字，自定义事件执行的函数</p><p>Fn(n){ }  n 就是传过来的值</p><p>在子组件中设置一个事件来触发自定义事件：</p><p>函数中写:  this.$emit(‘sj（自定义事件的名字）’, 需要传入的值)</p><ol start="19"><li>非父子组件之间如何进行通信</li></ol><p>在src下创建一个文件夹lib 在lib中创建一个bus.js 相当于公共文件</p><p>在兄弟组件中引用bus.js 文件 ，通过 this.$on(‘自定义事件名称’，执行函数)</p><p>在另一个兄弟组件中引用bus.js 文件，通过this.$emit(‘自定义事件名称’, 值)</p><ol start="20"><li>除了组件之间的这种通信方式以外，还是什么方式可以让组件的数据进行共享</li></ol><p>Vuex</p><ol start="21"><li>请你说一下vue中常用的指令有哪些</li></ol><p>插入文本:v-text  插入HMTL:v-html  循环:v-for  第二种：v-show  属性绑定:v-bind</p><p>双向绑定:v-model  绑定事件:v-on</p><ol start="22"><li>请你说一下为什么使用key</li></ol><p>key在vue中，有跟它意思一样的关键的作用，整个框架对数据的渲染方面，起到了至关重要的作用</p><p>当更新数据的过程中，如果没有key的存在，系统会自动默认更新数据之间所要区分的key值为undefined，根据undefined＝＝undefined，所以数据更新时会忽略特殊比对值的情况下自动按照对比为true的情况去更新渲染数据</p><p>特别是中途插入删除数据的过程中，会因为中间某条数据的缺少而进行从从数据更新点之后的所有数据的重新更新以及多出数据的重新创建，这跟vue框架的本质原则相违背。</p><p>添加key这个唯一标识后，vue中patch算法会按照前后对比的原则，收尾找相同节点，将数据一一比对，相同的节点就会只做循环，不会发生任何更新，减少多余更新渲染，最后只将更改后的数据渲染到框架中。（sameVnode方法来判断节点是否相同）</p><ol start="23"><li>说一下你对axios的理解</li></ol><p>基本promise的异步ajax请求库</p><p>浏览器端&#x2F;node端都可以使用</p><p>支持请求&#x2F;响应拦截器</p><p>支持请求取消</p><p>请求&#x2F;响应数据转换</p><p>批量发送多个请求</p><ol start="24"><li>说一下你对渐进式框架的理解</li></ol><p>就是一开始不需要你完全掌握它的全部功能特性，可以后续逐步增加功能。没有多做职责之外的事情</p><ol start="25"><li><p>说一下vue单页面和多页面的区别</p></li><li><p>请你说一下什么是vue的过滤器？你在项目中哪些地方使用过过滤器</p></li></ol><p>概念：本质上是函数；</p><p>作用：用户输入数据后，它能够进行处理，并返回一个数据结果；（无return语句不会报错，但是这种过滤器没有丝毫意义）</p><p>格式：管道符（ | ）进行连接，而管道符的作用就是：上一个命令的输出可以作为下一个命令的输入；</p><p>位置：只能是Mustache表达式、v-bind表达式；“</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Python 面试题&lt;/strong&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是python？使用python有什么好处&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答：1、python非常简单，适合阅读。这种这种伪代码本质是它最大的优点之一。它</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前端面试题</title>
    <link href="http://example.com/2022/06/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2022/06/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-06-27T23:33:45.000Z</published>
    <updated>2022-08-11T08:24:17.323Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、VUE-路由原理"><a href="#1、VUE-路由原理" class="headerlink" title="1、VUE 路由原理"></a>1、VUE 路由原理</h5><p>通过改变 URL，在不重新请求页面的情况下，更新页面视图。</p><p>更新视图但不重新请求页面，是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有 2 种方式：</p><p>· 利用 URL 中的 hash(“#”);</p><p>· 利用 History interface 在 HTML5 中新增的方法;<br><img src="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/img3.png"></p><h5 id="2、VUE-组件通信方式"><a href="#2、VUE-组件通信方式" class="headerlink" title="2、VUE 组件通信方式"></a>2、VUE 组件通信方式</h5><p>父子通信：</p><p>父向子传递数据是通过 props，子向父是通过 events（$emit）；通过父链 &#x2F; 子链也可以通信（$parent &#x2F; $children）；ref 也可以访问组件实例；provide &#x2F; inject API；$attrs&#x2F;$listeners</p><p>兄弟通信：</p><p>Bus；Vuex</p><p>跨级通信：</p><p>Bus；Vuex；provide &#x2F; inject API、$attrs&#x2F;$listeners</p><h5 id="3、你了解-vue-的-diff-算法吗？说说看"><a href="#3、你了解-vue-的-diff-算法吗？说说看" class="headerlink" title="3、你了解 vue 的 diff 算法吗？说说看"></a>3、你了解 vue 的 diff 算法吗？说说看</h5><p>diff 算法就是进行虚拟节点对比，并返回一个 patch 对象，用来存储两个节点</p><p>不同的地方，最后用 patch 记录的消息去局部更新 Dom。</p><p>其有两个特点：</p><p>比较只会在同层级进行, 不会跨层级比较</p><p>在 diff 比较的过程中，循环从两边向中间比较</p><p>43.Dom</p><p>真实 DOM，</p><p>DOM 是文档对象模型，</p><p>DOM 采用树形结构作为分层结构，以树节点形式表示页面中各种元素或内容在页面渲染出的每一个结点都是一个真实 DOM 结构，</p><p>虚拟 DOM</p><p>虚拟 Dom，本质上是以 JavaScript 对象形式存在的对 DOM 的描述。</p><p>创建虚拟 DOM 目的就是为了更好将虚拟的节点渲染到页面视图中，虚拟 DOM 对象</p><p>的节点与真实 DOM 的属性一一对应，为了简化视图的操作，解决跟踪状态变化的问</p><p>题，于是虚拟 DOM 出现了虚拟 DOM 的好处是当状态改变时不需要立即更新 DOM</p><p>，只需要创建一个虚拟树来描述 DOM，虚 DOM 内部将弄清楚如何有效的更新 DO</p><p>M，虚拟 DOM 可以维护程序的状态，跟踪上一次的状态通过比较前后两次状态的差</p><p>N，异更新真实 DOM</p><h5 id="4、Vue3-0-的设计目标是什么？做了那些优化"><a href="#4、Vue3-0-的设计目标是什么？做了那些优化" class="headerlink" title="4、Vue3.0 的设计目标是什么？做了那些优化"></a>4、Vue3.0 的设计目标是什么？做了那些优化</h5><p>复杂组件的代码变得越来越难以维护</p><p>缺少一种纯净的提取机制（使得多个组件之间逻辑的复用变得清晰易于维护）</p><p>类型推断不够友好，代码写的不够畅快</p><p>bundle 的时间相对较长（因为使用 webpack,所以打包机制决定了打包效率）</p><p>打包的体积整体变小。运行速度<strong>速度更快</strong><strong>*</strong>*<strong>，</strong><strong><strong>拥有*</strong></strong>*更灵活的代码组织能力</p><p><strong>优化：</strong></p><p><strong>源码，</strong></p><p>vue3 整个源码是通过 monorepo 的方式维护的，根据功能将不同的模块拆分到 packages 目录下面不同的子目录中。</p><p>这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性</p><p><strong>性能，</strong></p><p>· 体积优化</p><p>· 编译优化</p><p>· 数据劫持优化</p><p>在 vue2 中，数据劫持是通过 Object.defineProperty，这个 API 有一些缺陷，并不能检测对象属性的添加和删除</p><p>相比之下，vue3 是通过 proxy 监听整个对象，那么对于删除或者赋值都可以监听到，</p><p>但是 Proxy 并不能监听到内部深层次的对象变化，Vue3 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归，减少性能的开销。</p><p><strong>语法的 api</strong></p><p>· 优化逻辑组织</p><p>· 优化逻辑复用</p><h5 id="5、Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#5、Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="5、Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>5、Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h5><p>在逻辑组织和逻辑复用方面，Composition API 是优于 Options API</p><p>因为 Composition API 几乎是函数，会有更好的类型推断。</p><p>Composition API（自动删除无用代码） 代码也更容易压缩</p><p>Composition API 中见不到 this 的使用，减少了 this 指向不明的情况</p><h5 id="6、说一下-vue2-和-vue3-的数据响应式原理"><a href="#6、说一下-vue2-和-vue3-的数据响应式原理" class="headerlink" title="6、说一下 vue2 和 vue3 的数据响应式原理"></a>6、说一下 vue2 和 vue3 的数据响应式原理</h5><p><img src="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/img2.png"></p><p><strong>#####</strong></p><h5 id="7、说说你对盒子模型的理解"><a href="#7、说说你对盒子模型的理解" class="headerlink" title="7、说说你对盒子模型的理解"></a>7、说说你对盒子模型的理解</h5><p>有两种， IE 盒子模型（怪异盒子模型）、W3C 盒子模型（标准盒子模型）；</p><p>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；</p><p>区 别： IE 的 content 部分把 border 和 padding 计算了进去;</p><p>盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin)</p><p>IE8 及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE 盒模型)</p><p>标准(W3C)盒模型：元素宽度 &#x3D; width + padding + border + margin</p><p>怪异(IE)盒模型：元素宽度 &#x3D; width + margin</p><p>标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高</p><p>8、css 选择器有哪些？优先级？那些属性可以继承？</p><p>关于 css 属性选择器常用的有：</p><p>id 选择器（#box），选择 id 为 box 的元素</p><p>类选择器（.one），选择类名为 one 的所有元素</p><p>标签选择器（div），选择标签为 div 的所有元素</p><p>伪类选择器</p><p>伪元素选择器</p><p>属性选择器</p><p>优先级：内联 &gt; ID 选择器 &gt; 类选择器 &gt; 标签选择器</p><p>关于继承属性，可以分成：</p><p>字体系列属性</p><p>文本系列属性</p><p>元素可见性</p><p>表格布局属性</p><p>列表属性</p><p>光标属性</p><p>继承中比较特殊的几点：</p><p>a 标签的字体颜色不能被继承</p><p>h1-h6 标签字体的大下也是不能被继承的</p><p>无继承的属性</p><p>display</p><p>文本属性：vertical-align、text-decoration</p><p>盒子模型的属性：宽度、高度、内外边距、边框等</p><p>背景属性：背景图片、颜色、位置等</p><p>定位属性：浮动、清除浮动、定位 position 等</p><h5 id="9、元素的水平垂直居中的方法有哪些？如果元素不定宽高呢？"><a href="#9、元素的水平垂直居中的方法有哪些？如果元素不定宽高呢？" class="headerlink" title="9、元素的水平垂直居中的方法有哪些？如果元素不定宽高呢？"></a>9、元素的水平垂直居中的方法有哪些？如果元素不定宽高呢？</h5><p>实现元素水平垂直居中的方式：</p><p>利用定位+<a href="https://so.csdn.net/so/search?q=margin&spm=1001.2101.3001.7020">margin</a>:auto</p><p>利用定位+margin:负值</p><p>利用定位+transform</p><p>table 布局</p><p><a href="https://so.csdn.net/so/search?q=flex&spm=1001.2101.3001.7020">flex</a>布局</p><p>grid 布局</p><p>上述方法中，不知道元素宽高大小仍能实现水平垂直居中的方法有：</p><p>利用定位+margin:auto</p><p>利用定位+transform</p><p>利用定位+margin:负值</p><p>flex 布局</p><p>grid 布局</p><h5 id="10、怎么理解回流跟重绘？什么场景下会触发？"><a href="#10、怎么理解回流跟重绘？什么场景下会触发？" class="headerlink" title="10、怎么理解回流跟重绘？什么场景下会触发？"></a>10、怎么理解回流跟重绘？什么场景下会触发？</h5><p>重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。</p><p>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘</p><p>回流是布局或者几何属性需要改变就称为回流。</p><p>什么场景下会触发</p><p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><h5 id="11、什么是响应式设计？响应式设计的基本原理是什么？如何做"><a href="#11、什么是响应式设计？响应式设计的基本原理是什么？如何做" class="headerlink" title="11、什么是响应式设计？响应式设计的基本原理是什么？如何做"></a>11、什么是响应式设计？响应式设计的基本原理是什么？如何做</h5><p>响应式⽹站设计（Responsive Web design）是⼀种⽹络页⾯设计布局，页⾯的设计与开发应当根据⽤户⾏为以及设备环境(系统平台、屏幕尺⼨、屏幕定向等)进⾏相应的响应和调整</p><p>响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺⼨做处理，为了处理移动端，页⾯头部必须有 meta 声明 viewport</p><p>实现响应式布局的⽅式有如下：</p><p>媒体查询</p><p>百分⽐</p><p>vw&#x2F;vh</p><p>rem</p><h5 id="12、如果做优化，css-提高性能的方法有哪些？"><a href="#12、如果做优化，css-提高性能的方法有哪些？" class="headerlink" title="12、如果做优化，css 提高性能的方法有哪些？"></a>12、如果做优化，css 提高性能的方法有哪些？</h5><p>加载性能：</p><p>（1）css 压缩：将写好的 css 进行打包压缩，可以减少很多的体积。</p><p>（2）css 单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但 margin-bottom:bot</p><p>tom;margin-left:left;执行的效率更高。</p><p>（3）减少使用@import,而建议使用 link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</p><p><a href="https://so.csdn.net/so/search?q=%E9%80%89%E6%8B%A9%E5%99%A8&spm=1001.2101.3001.7020">选择器</a>性能：</p><p>减少标签选择，多用 class 选择器。</p><p>尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</p><p>了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</p><h5 id="13、对前端工程师这个职位是怎样理解的？它的前景会怎么样"><a href="#13、对前端工程师这个职位是怎样理解的？它的前景会怎么样" class="headerlink" title="13、对前端工程师这个职位是怎样理解的？它的前景会怎么样"></a>13、对前端工程师这个职位是怎样理解的？它的前景会怎么样</h5><p>通过各种终端来向用户展示数据，或者给用户提供一些和后台的交互接口。</p><p>前景：首先，在我看来，一切和用户交互的终端都可以属于前端。并且随着现在跨端开发框架的兴起，，也使得前端的那套开发技术栈以及开发流程可以复制到 pc 端来，使得前端的范畴越来越广泛。</p><p>并且，随着 AR，VR 技术的兴起，手机 app 中应用了大量的 3 维场景来提高用户体验，比如手机 app 上看房，看车，甚至是看一个城市的街景，都已经有了 3D 的场景，并且用户还能进行简单的操作。而这些都对前端提出了更高的要求</p><h5 id="14、说说-JavaScript-中的数据类型？存储上的差别？"><a href="#14、说说-JavaScript-中的数据类型？存储上的差别？" class="headerlink" title="14、说说 JavaScript 中的数据类型？存储上的差别？"></a>14、说说 JavaScript 中的数据类型？存储上的差别？</h5><p>JavaScript 一共有 8 种数据类型，其中有 7 种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol（es6 新增，表示独一无二的值）和 BigInt（es10 新增）；</p><p>1 种引用数据类型——Object（Object 本质上是由一组无序的名值对组成的）。里面包含 function、Array、Date 等。JavaScript 不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。</p><p>引用数据类型: 对象 Object（包含普通对象-Object，数组对象-Array，正则对象-Re gEx p，日期对象-Date，数学函数-Math，函数对象-Function）</p><p>在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间、堆空间。其中的代码空间主要是存储可执行代码的，原始类型的数据值都是直接保存在“栈”中的，引用类型(Object)的值是存放在“堆”中的。因此在栈空间中，原始类型存储的是变量的值，而引用类型存储的是其在”堆空间”中的地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的</p><h5 id="15、typeof-与-instanceof-区别"><a href="#15、typeof-与-instanceof-区别" class="headerlink" title="15、typeof 与 instanceof 区别"></a>15、typeof 与 instanceof 区别</h5><p>typeof 的返回值是一个字符串，对于基本类型，除了 null 都可以显示正确的类型</p><p>typeof 对于对象，除了函数都会显示 object</p><p>instanceof 返回值是布尔值，用于判断一个变量是否属于某个对象，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype</p><h5 id="16、JavaScript-本地存储的方式由哪些？区别及应用场景？"><a href="#16、JavaScript-本地存储的方式由哪些？区别及应用场景？" class="headerlink" title="16、JavaScript 本地存储的方式由哪些？区别及应用场景？"></a>16、JavaScript 本地存储的方式由哪些？区别及应用场景？</h5><p>javaScript 本地缓存的方法我们主要讲述以下四种：</p><p>cookie</p><p>sessionStorage</p><p><a href="https://so.csdn.net/so/search?q=localStorage&spm=1001.2101.3001.7020">localStorage</a></p><p>indexedDB</p><p>关于 cookie、sessionStorage、localStorage 三者的区别主要如下：</p><p>存储大小：cookie 数据大小不能超过 4k，sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大</p><p>有效时间：localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除；cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</p><p>数据与服务器之间的交互方式，cookie 的数据会自动的传递到服务器，服务器端也可以写 cookie 到客户端；sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存</p><h5 id="17、什么是防抖和节流？有什么区别？如何实现？"><a href="#17、什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="17、什么是防抖和节流？有什么区别？如何实现？"></a>17、什么是防抖和节流？有什么区别？如何实现？</h5><p>防抖：某一高频事件不断被触发时，仅在最后一次真正执行事件处理代码。</p><p>节流：某一高频事件被触发时，确保在每一个特定的时间段内被执行一次。</p><p>相似点：都是为应对事件持续频繁发生，造成前端性能下降或对后端服务造成的压力。</p><p>区别：节流会不断的触发，而防抖仅在最后一次触发。防抖适用于，如搜索输入框提示，仅在输入停止后进行一次提示更新，以减少后台压力。节流适用于，如窗体以拖动的方式调整大小，在每次特定的时间片结束后触发一次窗体大小调整。</p><p>节流的实现：</p><p>可以使用事件戳和定时器</p><p>使用事件戳写法，事件会立即执行，停止触发后没有办法再次执行</p><p>使用定时器的写法，自己决定多少毫秒后第一次执行，第二次事件停止触发后依然会在执行一次</p><p>防抖的实现：</p><p>在处理一段连续操作结束后，处理回调，利用 clearTimeout 和 setTimeout 实现</p><h5 id="18、如何通过-JS-判断一个人数组"><a href="#18、如何通过-JS-判断一个人数组" class="headerlink" title="18、如何通过 JS 判断一个人数组"></a>18、如何通过 JS 判断一个人数组</h5><p>1.Es5 新增的方法 isArray)</p><p>2.Instanceof 方法 是用来检测一个对象是否在其原型链原型构造函数的属性</p><p>3.Constructor 方法 返回对创建此对象的数组函数的引用，就是返回对象对应 的构造函数</p><p>4.jQuery 正在使用的 object.protype.toString.call(value) 写一个返回数据类型的方法</p><h5 id="19、说说你对作用域链的理解"><a href="#19、说说你对作用域链的理解" class="headerlink" title="19、说说你对作用域链的理解"></a>19、说说你对作用域链的理解</h5><p>作用域 就是变量 变量作用域又称上下文</p><p>作用域分为 全局，函数，块级 作用域</p><p>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到 window 对象即被终止，作用域链向下访问变量是不被允许的 即作用域控制着变量与函数的可见性和生命周期</p><h5 id="20、JavaScript-原型，原型链？有什么特点？"><a href="#20、JavaScript-原型，原型链？有什么特点？" class="headerlink" title="20、JavaScript 原型，原型链？有什么特点？"></a>20、JavaScript 原型，原型链？有什么特点？</h5><p><strong><strong>*</strong>*原型：**</strong>****</p><p>JavaScript 的所有对象中都包含了一个 [<strong>proto</strong>] 内部属性，这个属性所对应的就是该对象的原型</p><p>JavaScript 的函数对象，除了原型 [<strong>proto</strong>] 之外，还预置了 prototype 属性</p><p>当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [<strong>proto</strong>]。</p><p><strong><strong>*</strong>*原型链：**</strong>****</p><p>当一个对象调用的属性&#x2F;方法自身不存在时，就会去自己 [<strong>proto</strong>] 关联的前辈 prototype 对象上去找</p><p>如果没找到，就会去该 prototype 原型 [<strong>proto</strong>] 关联的前辈 prototype 去找。依次类推，直到找到属性&#x2F;方法或 undefined 为止。从而形成了所谓的“原型链”</p><p><strong><strong>*</strong>*原型特点：**</strong>****</p><p>JavaScript 对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变</p><h5 id="21、请解释什么是事件代理"><a href="#21、请解释什么是事件代理" class="headerlink" title="21、请解释什么是事件代理"></a>21、请解释什么是事件代理</h5><p>事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是 DOM 元素的事件冒泡。</p><p>使用事件代理的好处是可以提高性能可以大量节省内存占用，减少事件注册</p><p>可以实现当新增子对象时无需再次对其绑定</p><h5 id="22、请谈谈-This-对象的理解"><a href="#22、请谈谈-This-对象的理解" class="headerlink" title="22、请谈谈 This 对象的理解"></a>22、请谈谈 This 对象的理解</h5><p>在浏览器里，在全局范围内 this 指向 window 对象；</p><p>在函数中，this 永远指向最后调用他的那个对象；</p><p>构造函数中，this 指向 new 出来的那个新的对象；</p><p>call、apply、bind 中的 this 被强绑定在指定的那个对象上；</p><p>箭头函数中 this 比较特殊,箭头函数 this 为父作用域的 this，而箭头函数的 this 指向是静态的,声明的时候就确定了下来；</p><h5 id="23、new-操作符具体干了什么"><a href="#23、new-操作符具体干了什么" class="headerlink" title="23、new 操作符具体干了什么"></a>23、new 操作符具体干了什么</h5><p>创建一个新对象,作为返回的实例对象</p><p>将空对象的原型-proto-指向构造函数的 protptype 属性</p><p>对象连接到构造函数原型上，并绑定 <code>this</code>（this 指向新对象）</p><p>执行构造函数代码（为这个新对象添加属性）</p><p>返回新对象</p><p>（1）首先创建了一个新的空对象。</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</p><h5 id="24、null，undefined-的区别"><a href="#24、null，undefined-的区别" class="headerlink" title="24、null，undefined 的区别"></a>24、null，undefined 的区别</h5><p>undefined：声明了变量但未赋值</p><p>null 是一个空对象，对象已经被定义但是值为空值</p><p>在验证 null 和 undefind 时要用&#x3D;&#x3D;&#x3D;（数据类型转化）而不是&#x3D;&#x3D;，&#x3D;&#x3D;无法分辨 null undefined</p><h5 id="25、JavaScript-代码中“use-strict”；是什么意思"><a href="#25、JavaScript-代码中“use-strict”；是什么意思" class="headerlink" title="25、JavaScript 代码中“use strict”；是什么意思"></a>25、JavaScript 代码中“use strict”；是什么意思</h5><p>use strict 是 es5 中的严格模式，利用严格模式使代码编写更加规范，避免不合理的语法，和一些异常操作</p><h5 id="26、同步和异步的区别"><a href="#26、同步和异步的区别" class="headerlink" title="26、同步和异步的区别"></a>26、同步和异步的区别</h5><p>同步，在任务执行过程中如果需要一段时间才能返回信息，那么这个进程就会一直等下去，直到可以返回信息再执行</p><p>异步不会一直等待，不管其他进程的状态，直接进行下面的操作，提高了执行效率</p><h5 id="27、谈一谈箭头函数与普通函数的区别"><a href="#27、谈一谈箭头函数与普通函数的区别" class="headerlink" title="27、谈一谈箭头函数与普通函数的区别"></a>27、谈一谈箭头函数与普通函数的区别</h5><p>不能作为构造函数，不能使用 new。</p><p>1：写法不一样</p><p>2：普通函数存在变量提升的现象</p><p>3：箭头函数是匿名函数，不能作为构造函数使用，不能使用 new。</p><p>4：两者 this 的指向不同</p><p>5：箭头函数的 arguments 指向它的父级函数所在作用域的 arguments</p><p>6：箭头函数没有 new.target</p><p>箭头函数</p><p>箭头函数的 this 指向父级作用域的 this，</p><p>箭头函数没有 prototype 原型.</p><p>箭头函数不能作为构造函数。</p><p>普通函数的 this</p><p>1、普通函数最终指向调用它的对象，也就是说谁调用就指向谁。</p><p>2、没有被对象调用的函数默认指向 windows</p><h5 id="28、JS-数组和对象的遍历方式，以及几种方式的比较"><a href="#28、JS-数组和对象的遍历方式，以及几种方式的比较" class="headerlink" title="28、JS 数组和对象的遍历方式，以及几种方式的比较"></a>28、JS 数组和对象的遍历方式，以及几种方式的比较</h5><p><img src="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/img1.png"></p><hr><h5 id="29、如何解决跨域问题"><a href="#29、如何解决跨域问题" class="headerlink" title="29、如何解决跨域问题"></a>29、如何解决跨域问题</h5><p>通过 jsonp 跨域</p><p>document.domain + iframe 跨域</p><p>nginx 代理跨域</p><p>nodejs 中间件代理跨域</p><p>后端在头部信息里面设置安全域名</p><p>方式 1：6 资源共享（cors）</p><p>浏览器将 CORS 请求分成两类：简单请求（simple request）和预检请求。</p><p>解决方式就是服务端在响应头中加入字段：Access-Control-Allow-Origin:Origion,那么该 Origion 就可以访问了。如果该字段值为’*‘那么所有 Origion 均可访问</p><p>方式 2：jsonp</p><p>通常为了减轻 web 服务器的负载，我们把 js、css，img 等静态资源分离到另一台独立域名的服务器上，在 html 页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建 script，再请求一个带参网址实现跨域通信。</p><p>不过我们又发现，Web 页面上调用 js 文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如“&lt;“script”&gt;”、“&lt;”img“&gt;”、&lt;“iframe”&gt;）</p><p>于是可以判断，当前阶段如果想通过纯 web 端跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进 js 格式的文件里，供客户端调用和进一步处理；</p><p>方式 3：vue 中设置代理服务器</p><p>跨域问题只存在浏览器，如果是服务器和服务器之间的通信是不存在跨域问题的</p><p>可以在 vue-cli 中设置代理服务器实现跨域请求</p><h5 id="30、XML-和-JSON-的区别"><a href="#30、XML-和-JSON-的区别" class="headerlink" title="30、XML 和 JSON 的区别"></a>30、XML 和 JSON 的区别</h5><p>XML 是<a href="https://so.csdn.net/so/search?q=%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80&spm=1001.2101.3001.7020">可扩展标记语言</a>，标记语言就是通过一个一个的标记来组织数据的一种语法格式。</p><p>JSON 是一种轻量级的数据交换格式，可使人们很容易地进行阅读和编写，同时也方便了机器进行解析和生成。JSON 适用于进行数据交互的场景，如网站前台与后台之间的数据交互。</p><p>数据交互 json 比 xml 交互更好，容易被解析</p><p>传输速度 json 比 xml 传输速度更快</p><p>数据描述 json 比 xml 描述更细致</p><p>体积 json 比 xml 体积小，传输速度快</p><h5 id="31、-谈谈你对-webpack-的看法"><a href="#31、-谈谈你对-webpack-的看法" class="headerlink" title="31、 谈谈你对 webpack 的看法"></a>31、 谈谈你对 webpack 的看法</h5><p>webpack 是用来管理模块包的工具，在项目开发中可以打包模块依赖，对静态资源进行解析。在 web 开发过程中打包 ht js css 等静态资源，开发更加高效。对于不同类型的资源，webpack 有模块加载器对模块包分析他们之间的依赖关系，最终优化合并为静态资源</p><h5 id="32、webpack-的打包原理"><a href="#32、webpack-的打包原理" class="headerlink" title="32、webpack 的打包原理"></a>32、webpack 的打包原理</h5><p><img src="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/img4.png"></p><h5 id="33、-如何优化-webpack-打包速度"><a href="#33、-如何优化-webpack-打包速度" class="headerlink" title="33、 如何优化 webpack 打包速度"></a>33、 如何优化 webpack 打包速度</h5><p><img src="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/img5.jpg"></p><h5 id="34、-说说-webpack-中常见的-Loader？解决了什么问题？"><a href="#34、-说说-webpack-中常见的-Loader？解决了什么问题？" class="headerlink" title="34、 说说 webpack 中常见的 Loader？解决了什么问题？"></a>34、 说说 webpack 中常见的 Loader？解决了什么问题？</h5><p>loader 用于对模块的源代码进行转换，在 import 或‘加载’模块时<a href="https://so.csdn.net/so/search?q=%E9%A2%84%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020">预处理</a>文件</p><p><img src="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/34.png"></p><h5 id="35、说说-webpack-中常见的-Plugin？解决了什么问题？"><a href="#35、说说-webpack-中常见的-Plugin？解决了什么问题？" class="headerlink" title="35、说说 webpack 中常见的 Plugin？解决了什么问题？"></a>35、说说 webpack 中常见的 Plugin？解决了什么问题？</h5><p>Plugin（Plug-in）是一种计算机应用程序，它和主应用程序互相交互，以提供特定的功能</p><p><img src="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/35.png"></p><h5 id="36、说说你对promise的了解"><a href="#36、说说你对promise的了解" class="headerlink" title="36、说说你对promise的了解"></a>36、说说你对promise的了解</h5><p>1.异步操作的解决方案</p><p>Promise 是一种异步操作的解决方案，将写法复杂的传统的回调函数和监听事件的异</p><p>步操作，用同步代码的形式表达出来。避免了多级异步操作的回调函数嵌套。</p><p>主要用于异步计算</p><ol start="2"><li>作为对象，内部有三种状态</li></ol><p>初始状态（ pending ）。</p><p>已完成（ resolve）：resolve 方法可以使 Promise 对象的状态改变成成功</p><p>已拒绝（ reject ）：reject 方法则是将 Promise 对象的状态改变为失败</p><p>3.常用的三种方法</p><p>第一种：then 表示异步成功执行后的数据状态变为 resolve</p><p>第二种：catch 表示异步失败后执行的数据状态变为 reject</p><p>第三种：all 表示把多个没有关系的 Promise 封装成一个 Promise 对象，使用</p><p>then 返回一个数组数据。</p><p>5.在哪里使用过</p><p>Ajax 异步请求的时候</p><p>函数嵌套层级多的时候使用 promise，优点在于，回调函数变成了链式写法，程序的</p><p>流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。</p><h5 id="36、async函数是什么，有什么作用"><a href="#36、async函数是什么，有什么作用" class="headerlink" title="36、async函数是什么，有什么作用"></a>36、async函数是什么，有什么作用</h5><p>async函数是使用async关键字声明的函数。 async函数是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction">AsyncFunction</a>构造函数的实例， 并且其中允许使用await关键字。async和await关键字让我们可以用一种更简洁的方式写出基于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>的异步行为，而无需刻意地链式调用promise。</p><h5 id="37、有使用过vue吗？说说你对vue的理解"><a href="#37、有使用过vue吗？说说你对vue的理解" class="headerlink" title="37、有使用过vue吗？说说你对vue的理解"></a>37、有使用过vue吗？说说你对vue的理解</h5><p><img src="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/37.png"></p><h5 id="38、你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"><a href="#38、你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢" class="headerlink" title="38、你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"></a>38、你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢</h5><p><img src="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/38.png"></p><h5 id="39、-SPA首屏加载速度慢的怎么解决？"><a href="#39、-SPA首屏加载速度慢的怎么解决？" class="headerlink" title="39、 SPA首屏加载速度慢的怎么解决？"></a>39、 SPA首屏加载速度慢的怎么解决？</h5><p><img src="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/39.png"></p><h5 id="40、说说对-React-的理解？有哪些特性？"><a href="#40、说说对-React-的理解？有哪些特性？" class="headerlink" title="40、说说对 React 的理解？有哪些特性？"></a>40、说说对 React 的理解？有哪些特性？</h5><p>是什么 React，用于构建用户界面的 JavaScript 库，提供了 UI 层面的解决方案，遵循组件设计模式、声明式编程范式和函数式编程概念，以使前端应用程序更高效，使用虚拟DOM来有效地操作DOM，遵循从高阶组件到低阶组件的单向数据流,帮助我们将界面成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，构成整体页面. </p><p>特性 </p><p>JSX语法单向数据绑定虚拟DOM，声明式编程，Component(组件化) </p><p>优势 </p><p>高效灵活声明式的设计，简单使用组件式开发，提高代码复用率单向响应的数据流会比双向绑定的更安全，速度更快 </p><p>什么是高阶组件？ </p><p>高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。基本上，这是从React的组成性质派生的一种模式，我们称它们为“纯”组件， 因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件的任何行为。 </p><p> 什么是JSX和它的特性？ </p><p>JSX 是JavaScript XML的缩写，，基于ECMAScript的一种新特性，一种定义带属性树结构的语法； </p><p>特性： </p><p>自定义组件名首字母大写嵌套；在render函数中return返回的只能包含一个顶层标签，否则也会报错。求值表达式；JSX基本语法规则，遇到HTML标签（以&lt;开头），就用HTML规则解析；遇到代码块（以{开头），就用JS规则解析驼峰命名class属性需要写成classNameJSX允许直接在模板插入JS变量。如果这个变量是一个数组，则会展开这个数组的所有成员。在JSX中插入用户输入是安全的，默认情况下ReactDOM会在渲染前，转义JSX中的任意值，渲染前，所有的值都被转化为字符串形式，这能预防XSS攻击。 </p><h5 id="41、说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？"><a href="#41、说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？" class="headerlink" title="41、说说 Real DOM 和 Virtual DOM 的区别？优缺点？"></a>41、说说 Real DOM 和 Virtual DOM 的区别？优缺点？</h5><p>真实 DOM，</p><p>DOM是文档对象模型，</p><p>DOM采用树形结构作为分层结构，以树节点形式表示页面中各种元素或内容在页面渲染出的每一个结点都是一个真实DOM结构，</p><p>虚拟DOM </p><p>虚拟Dom，本质上是以 JavaScript 对象形式存在的对 DOM 的描述。</p><p><em><strong>*区别：*</strong></em></p><p>\1. 虚拟dom不会进行重绘和回流，而真实dom会频繁重排与重绘</p><p>\2. 虚拟dom的总损耗是”虚拟dom的增删改+真实dom的****差异****增删改+重排“；真实dom的消耗是”真实dom全部增删改+重排“</p><p>.优缺点</p><p>1.真实dom</p><p> 优点：</p><ol><li>直接操作HTML，易用</li></ol><p> 缺点：</p><ol><li><p>解析速度慢，效率低，内存占用量高</p></li><li><p>性能差：频繁操作真实DOM，导致重绘、回流</p></li></ol><p>2.虚拟dom</p><ol><li><p>减少真实dom的频繁更新，减少重绘回流、占用内存少</p></li><li><p>跨平台：一套react代码可以多端运行</p></li></ol><p> 优点：</p><p> 缺点：</p><p>​1.页面首次渲染时，由于多一层虚拟dom的计算，速度比正常慢些</p><h5 id="42、-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？"><a href="#42、-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？" class="headerlink" title="42、 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？"></a>42、 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？</h5><p>Mounting(挂载阶段)：已插入真实 DOM<br>Updating(更新阶段)：正在被重新渲染<br>Unmounting(卸载阶段)：已移出真实 DOM</p><p>挂载阶段</p><p>· constructor() 在 React 组件挂载之前，会调用它的构造函数。</p><p>· componentWillMount: 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。</p><p>· componentDidMount(): 在组件挂载后（插入 DOM 树中）立即调用</p><p>更新运行阶段:</p><p>· componentWillReceiveProps: 在接受父组件改变后的props需要重新渲染组件时用</p><p>· shouldComponentUpdate():用于控制组件重新渲染的生命周期，state发生变化，组件会进入重新渲染</p><p>render(): class 组件中唯一必须实现的方法。</p><p><em>componentWillUpdate()</em> : shouldComponentUpdate返回true以后，组件进入重新渲染完成之前进入这个函数。</p><p>componentDidUpdate(): 每次state改变并重新渲染页面后都会进入这个生命周期</p><p>卸载或销毁阶段<br>    componentWillUnmount ()： 在此处完成组件的卸载和数据的销毁。</p><p> <img src="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/42.png"></p><h5 id="43、-说说-React中的setState执行机制"><a href="#43、-说说-React中的setState执行机制" class="headerlink" title="43、 说说 React中的setState执行机制"></a>43、 说说 React中的setState执行机制</h5><p>一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是state</p><p>当需要修改里面的值的状态需要通过调用setState来改变，从而达到更新组件内部数据的作用</p><p>在使用setState更新数据的时候，setState的更新类型分成：</p><p>异步更新</p><p>同步更新</p><h5 id="44、说说对React中类组件和函数组件的理解？有什么区别？"><a href="#44、说说对React中类组件和函数组件的理解？有什么区别？" class="headerlink" title="44、说说对React中类组件和函数组件的理解？有什么区别？"></a>44、说说对React中类组件和函数组件的理解？有什么区别？</h5><p>类组件： 类组件，顾名思义，也就是通过使用ES6类的编写形式去编写组件，该类必须继承React.Component如果想要访问父组件传递过来的参数，可通过this.props的方式去访问在组件中必须实现render方法，在return中返回React对象</p><p>函数组件： </p><p>函数组件接收一个单一的 props 对象并返回了一个React元素。函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。 </p><p>编写形式</p><p>状态管理</p><p>生命周期 函数式组件没有生命周期，这是因为这些生命周期钩子都来自于继承的React.Component </p><p>调用方式</p><p>如果是一个函数组件，调用则是执行函数即可如果是一个类组件，则需要将组件进行实例化，然后调用实例对象的render方法：<strong>获取渲染的值</strong></p><h5 id="45、-说说对React-Hooks的理解？解决了什么问题？"><a href="#45、-说说对React-Hooks的理解？解决了什么问题？" class="headerlink" title="45、 说说对React Hooks的理解？解决了什么问题？"></a>45、 说说对React Hooks的理解？解决了什么问题？</h5><p>它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</p><p>难以重用和共享组件中的与状态相关的逻辑</p><p>逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面</p><p>类组件中的this增加学习成本，类组件在基于现有工具的优化上存在些许问题</p><p>由于业务变动，函数组件不得不改为类组件等等</p><p>useState </p><p>useEffect</p><p>useReducer</p><p>useCallback</p><p>useMemo</p><p>useRef</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1、VUE-路由原理&quot;&gt;&lt;a href=&quot;#1、VUE-路由原理&quot; class=&quot;headerlink&quot; title=&quot;1、VUE 路由原理&quot;&gt;&lt;/a&gt;1、VUE 路由原理&lt;/h5&gt;&lt;p&gt;通过改变 URL，在不重新请求页面的情况下，更新页面视图。&lt;/p&gt;
&lt;p&gt;更</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>React性能优化</title>
    <link href="http://example.com/2022/06/13/React/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2022/06/13/React/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2022-06-13T02:50:39.000Z</published>
    <updated>2022-08-18T01:30:26.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>React凭借着Virtual DOM和diff算法拥有高效的性能，但是某些情况下，性能明显可以进一步提高</p><blockquote><p>在我们类组件通过调用setState方法，就会导致render，父组件一旦发生render渲染，子组件一定会执行render渲染，理想状态只调用该路径下的组件render，但是react的默认做法是调用所有组件的render，在对生成的虚拟DOM进行对比，如果没变就不进行更新，这种diff算法对比是明显的性能浪费的情况</p></blockquote><h2 id="如何做"><a href="#如何做" class="headerlink" title="如何做"></a>如何做</h2><p>在React中如何避免不必要的render，主要手段是通过shouldComponentUpdate、PureComponent、React.memo，这三种形式<br>除此之外常见的性能优化手段有</p><ul><li>避免使用内联函数</li><li>使用React Fragments避免额外标记</li><li>使用Immutable</li><li>懒加载组件</li><li>事件绑定方式</li><li>服务端渲染</li></ul><h3 id="避免使用内联函数"><a href="#避免使用内联函数" class="headerlink" title="避免使用内联函数"></a>避免使用内联函数</h3><blockquote><p>如果我们使用内联函数，则每次调用render函数时都会创建一个新的函数实例，如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default class InlineFunctionComponent extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Welcome Guest&lt;/h1&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; onClick=&#123;(e) =&gt; &#123; this.setState(&#123;inputValue: e.target.value&#125;) &#125;&#125; value=&quot;Click For Inline Function&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们应该在组件内部创建一个函数，并将事件绑定到该函数本身。这样每次调用render时 就不会生成单独的函数实例，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default class InlineFunctionComponent extends React.Component &#123;</span><br><span class="line">  </span><br><span class="line">  setNewStateData = (event) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      inputValue: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Welcome Guest&lt;/h1&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; onClick=&#123;this.setNewStateData&#125; value=&quot;Click For Inline Function&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用React-Fragments避免额外标记"><a href="#使用React-Fragments避免额外标记" class="headerlink" title="使用React Fragments避免额外标记"></a>使用React Fragments避免额外标记</h3><ul><li>用户创建组件时，每个组件应具有单个父标签。父级不能有两个标签，所以顶部要有一个公共标签，所以我们经常在组件顶部添加额外标签div</li><li>这个额外标签除了充当父标签之外，并没有其他作用，这时候则可以使用fragment</li><li>其不会向组件引入任何额外标记，但它可以作为父级标签的作用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default class NestedRoutingComponent extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;h1&gt;This is the Header Component&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;Welcome To Demo Page&lt;/h2&gt;</span><br><span class="line">            &lt;/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="事件绑定方式"><a href="#事件绑定方式" class="headerlink" title="事件绑定方式"></a>事件绑定方式</h3><ul><li>在事件绑定方式中，我们了解到四种事件绑定的方式</li><li>从性能方面考虑，在render方法中使用bind和render方法中使用箭头函数这两种形式在每次组件render的时候都会生成新的方法实例，性能欠缺</li><li>而constructor中bind事件与与定义阶段使用箭头函数绑定这两种形式只会生成一个方法实例，性能方面会有所改善</li></ul><h3 id="使用Imnutable"><a href="#使用Imnutable" class="headerlink" title="使用Imnutable"></a>使用Imnutable</h3><ul><li>使用Immutable可以给React带来性能的优化，主要体现在减少渲染的次数</li><li>在做react性能优化的时候，为了避免重复，我们会在shouldComponentUpdate()中做对比，当返回true执行render方法</li><li>Immutable通过is方法则可以完成对比，而无需像一样通过深度比较的方式比较</li></ul><h3 id="懒加载组件"><a href="#懒加载组件" class="headerlink" title="懒加载组件"></a>懒加载组件</h3><ul><li>从工程方面考虑，webpack存在代码拆分能力，可以为应用创建多个包，并在运行时动态加载，减少初始包的大小</li><li>而在react中使用到了Supense和lazy组件实现代码拆分功能，基本使用如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const johanComponent = React.lazy(() =&gt; import(/* webpackChunkName: &quot;johanComponent&quot; */ &#x27;./myAwesome.component&#x27;));</span><br><span class="line"> </span><br><span class="line">export const johanAsyncComponent = props =&gt; (</span><br><span class="line">  &lt;React.Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt;</span><br><span class="line">    &lt;johanComponent &#123;...props&#125; /&gt;</span><br><span class="line">  &lt;/React.Suspense&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><ul><li>采用服务端渲染方式，用户可以更快的看到渲染完成的页面</li><li>服务端渲染，需要一个node服务，可以用express、koa等，调用react的renderTostring方法，将组件渲染成字符串，在输出到响应中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; renderToString &#125; from &quot;react-dom/server&quot;;</span><br><span class="line">import MyPage from &quot;./MyPage&quot;;</span><br><span class="line">app.get(&quot;/&quot;, (req, res) =&gt; &#123;</span><br><span class="line">  res.write(&quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;);</span><br><span class="line">  res.write(&quot;&lt;div id=&#x27;content&#x27;&gt;&quot;);  </span><br><span class="line">  res.write(renderToString(&lt;MyPage/&gt;));</span><br><span class="line">  res.write(&quot;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>客户端使用render方法来生成html<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import MyPage from &quot;./MyPage&quot;;</span><br><span class="line">ReactDOM.render(&lt;MyPage /&gt;, document.getElementById(&#x27;app&#x27;));</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>除此之外，还存在的优化手段有组件拆分、合理使用hooks等性能优化手段</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面初步学习，我们了解到react常见的性能优化可以分成三个层面来执行</p><ul><li>代码层面</li><li>工程层面</li><li>框架机制层面</li></ul><p>通过这三个层面的优化结合，能够使基于react项目的性能更上一层楼。</p>]]></content>
    
    
    <summary type="html">浅析React中性能优化的手段</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="-React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>为什么访问data中的属性不需要带data</title>
    <link href="http://example.com/2022/06/13/Vue3/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BF%E9%97%AEdata%E5%B1%9E%E6%80%A7%E4%B8%8D%E9%9C%80%E8%A6%81%E5%B8%A6data/"/>
    <id>http://example.com/2022/06/13/Vue3/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BF%E9%97%AEdata%E5%B1%9E%E6%80%A7%E4%B8%8D%E9%9C%80%E8%A6%81%E5%B8%A6data/</id>
    <published>2022-06-13T01:13:23.000Z</published>
    <updated>2022-08-16T06:35:27.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么访问data中的属性不需要带data"><a href="#为什么访问data中的属性不需要带data" class="headerlink" title="为什么访问data中的属性不需要带data"></a>为什么访问data中的属性不需要带data</h3><blockquote><p>vue中访问属性代理this.data.xxx 转换 this.xxx 的实现</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> /** 将 某一个对象的属性 访问 映射到 对象的某一个属性成员上 */</span><br><span class="line">function proxy( target, prop, key ) &#123;</span><br><span class="line">  Object.defineProperty( target, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get () &#123;</span><br><span class="line">      return target[ prop ][ key ];</span><br><span class="line">    &#125;,</span><br><span class="line">    set ( newVal ) &#123;</span><br><span class="line">      target[ prop ][ key ] = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">为什么访问data中的属性不需要带data</summary>
    
    
    
    <category term="Vue3" scheme="http://example.com/categories/Vue3/"/>
    
    
    <category term="-Vue3" scheme="http://example.com/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>发布订阅者模式和观察者模式的区别</title>
    <link href="http://example.com/2022/03/19/JavaScript/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/03/19/JavaScript/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-03-19T09:03:26.000Z</published>
    <updated>2022-08-16T01:52:17.125Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是观察者模式"><a href="#什么是观察者模式" class="headerlink" title="什么是观察者模式"></a>什么是观察者模式</h3><blockquote><p>定义：当对象之间存在一对多的依赖关系的时候，其中一个对象的状态发生改变，所有一栏他的对象都会收到通知，这就是观察者模式。</p></blockquote><ul><li>在观察者模式中，只有两种主题：目标对象(Object)和观察者(Observer)<blockquote><p>目标对象Subject</p><ul><li>维护观察者列表<code>oberverList</code></li></ul></blockquote><ul><li>定义添加观察者的方法</li><li>当自身发生变化后，通过调用自己的notify方法依次通知每个观察者执行<code>update</code>方法</li></ul></li><li>观察者Observer需要实现update方法，供目标对象调用。update方法中可以执行自定义的业务逻辑—弟子们需要定义接受任务通知后的方法，例如去抢任务或者任务不合适继续等待下个任务。</li></ul><h3 id="什么是发布定义者模式"><a href="#什么是发布定义者模式" class="headerlink" title="什么是发布定义者模式"></a>什么是发布定义者模式</h3><blockquote><p>定义：基于一个事件（主题）通道，希望接受通知的对象Subscriber通过自定义事件订阅主题，被激活事件的对象Publisher通过发布主题事件的方式通知各个订阅该主题的Subscriber对象。</p></blockquote><p>因此发布者订阅模式与观察者模式相比，发布订阅模式中有三个角色，发布者Publisher，事件调度中心Event Channel，订阅者Subscriber。<br>目标对象Subject:<br>任务发布者 – 发布者Publisher<br>中介功能 – Event Channel</p><ul><li>维护任务类型，以及每种任务下的订阅情况</li><li>给订阅者提供订阅功能 – subscribe功能</li><li>当主题发布任务后，中介会给所有订阅者发布任务 – publish功能</li></ul><p>任务接受者 – Subscriber<br>观察者Observer需要实现update方法，供目标调用。update方法中可以执行自定义的业务逻辑</p><blockquote><p>发布者和订阅者都不知道对方的存在。需要第三方中介，将订阅者和发布者串联起来，利用中介过滤和分配所有输入的消息。也就是说发布-订阅者模式用来处理不同系统组件的信息交流，即使这些组件不知道对方的存在。<br>例如 ：<br>平台提供了消息订阅的功能，如果你选择订阅，平台更新电视剧之后会第一时间发消息通知你，订阅后，你就可以愉快的追剧了。这个案例中 电视剧就是发布者Publisher，追剧人就是订阅者Subscribe，平台则承担了事件通道Event Channel功能。</p></blockquote><p>总结：</p><table><thead><tr><th>设计模式</th><th>观察者模式</th><th>订阅发布者模式</th></tr></thead><tbody><tr><td>主体</td><td>Object观察者、Subject目标对象</td><td>Publisher发布者、Event Channel事件中心、Subscribe订阅者</td></tr><tr><td>主体关系</td><td>subject中通过observerList记录ObServer</td><td>Publisher和Subscribe不知道对方，通过中介联系</td></tr><tr><td>优点</td><td>角色明确，Subject和Object要遵循约定的成员方法</td><td>松散耦合，灵活度高，通常应用在异步编程中</td></tr><tr><td>缺点</td><td>紧耦合</td><td>当事件类型变多时，会增加维护成本</td></tr><tr><td>使用案例</td><td>双向数据绑定</td><td>事件总线EventBus</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">发布订阅者模式和观察者模式的区别</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="-JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端的优化</title>
    <link href="http://example.com/2021/10/17/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/10/17/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BC%98%E5%8C%96/</id>
    <published>2021-10-17T03:23:20.000Z</published>
    <updated>2022-08-18T00:33:10.578Z</updated>
    
    
    <summary type="html">前端的优化策略有哪些</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="-前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="-HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>实现数组扁平化</title>
    <link href="http://example.com/2021/10/17/JavaScript/%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3/"/>
    <id>http://example.com/2021/10/17/JavaScript/%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3/</id>
    <published>2021-10-17T03:23:20.000Z</published>
    <updated>2022-08-18T01:40:26.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-方法一：普通的递归实"><a href="#1-方法一：普通的递归实" class="headerlink" title="1. 方法一：普通的递归实"></a>1. 方法一：普通的递归实</h3><blockquote><p>普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接。我们来看下这个方法是如何实现的，如下所示</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 方法1</span><br><span class="line">var a = [1, [2, [3, 4, 5]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  let result = [];</span><br><span class="line"></span><br><span class="line">  for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if(Array.isArray(arr[i])) &#123;</span><br><span class="line">      result = result.concat(flatten(arr[i]));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">flatten(a);  //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><p>从上面这段代码可以看出，最后返回的结果是扁平化的结果，这段代码核心就是循环遍历过程中的递归操作，就是在遍历过程中发现数组元素还是数组的时候进行递归操作，把数组的结果通过数组的 concat 方法拼接到最后要返回的 result 数组上，那么最后输出的结果就是扁平化后的数组</p><h3 id="2-方法二：利用-reduce-函数迭代"><a href="#2-方法二：利用-reduce-函数迭代" class="headerlink" title="2. 方法二：利用 reduce 函数迭代"></a>2. 方法二：利用 reduce 函数迭代</h3><blockquote><p>从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么我们其实也可以用 reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 方法2</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.reduce(function(prev, next)&#123;</span><br><span class="line">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr));//  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><h3 id="3-方法三：扩展运算符实现"><a href="#3-方法三：扩展运算符实现" class="headerlink" title="3. 方法三：扩展运算符实现"></a>3. 方法三：扩展运算符实现</h3><blockquote><p>这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的，还是来看一下代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方法3</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><p>从执行的结果中可以发现，我们先用数组的 some 方法把数组中仍然是组数的项过滤出来，然后执行 concat 操作，利用 ES6 的展开运算符，将其拼接到原数组中，最后返回原数组，达到了预期的效果。</p><p>前三种实现数组扁平化的方式其实是最基本的思路，都是通过最普通递归思路衍生的方法，尤其是前两种实现方法比较类似。值得注意的是 reduce 方法，它可以在很多应用场景中实现，由于 reduce 这个方法提供的几个参数比较灵活，能解决很多问题，所以是值得熟练使用并且精通的</p><h3 id="4-方法四：split-和-toString-共同处理"><a href="#4-方法四：split-和-toString-共同处理" class="headerlink" title="4. 方法四：split 和 toString 共同处理"></a>4. 方法四：split 和 toString 共同处理</h3><p>我们也可以通过 split 和 toString 两个方法，来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 方法4</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.toString().split(&#x27;,&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组，你可以在控制台执行一下查看结果。</p><h3 id="5-方法五：调用-ES6-中的-flat"><a href="#5-方法五：调用-ES6-中的-flat" class="headerlink" title="5. 方法五：调用 ES6 中的 flat"></a>5. 方法五：调用 ES6 中的 flat</h3><blockquote><p>我们还可以直接调用 ES6 中的 flat 方法，可以直接实现数组扁平化。先来看下 flat 方法的语法：<br>arr.flat([depth])<br>其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。那么如果多层的该怎么处理呢？参数也可以传进 Infinity，代表不论多少层都要展开。那么我们来看下，用 flat 方法怎么实现，请看下面的代码。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 方法5</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  return arr.flat(Infinity);</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><p>可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。<br>因此，你在编程过程中，发现对数组的嵌套层数不确定的时候，最好直接使用 Infinity，可以达到扁平化。下面我们再来看最后一种场景</p><h3 id="6-方法六：正则和-JSON-方法共同处理"><a href="#6-方法六：正则和-JSON-方法共同处理" class="headerlink" title="6. 方法六：正则和 JSON 方法共同处理"></a>6. 方法六：正则和 JSON 方法共同处理</h3><blockquote><p>我们在第四种方法中已经尝试了用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组。请看下面的代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方法 6</span><br><span class="line">let arr = [1, [2, [3, [4, 5]]], 6];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  let str = JSON.stringify(arr);</span><br><span class="line">  str = str.replace(/(\[|\])/g, &#x27;&#x27;);</span><br><span class="line">  str = &#x27;[&#x27; + str + &#x27;]&#x27;;</span><br><span class="line">  return JSON.parse(str); </span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><p><img src="https://s.poetries.work/images/20210414170438.png"> </p>]]></content>
    
    
    <summary type="html">实现数组扁平化的六种方式</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="-JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>图片懒加载和预加载的区别</title>
    <link href="http://example.com/2021/08/13/Html/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/08/13/Html/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-08-13T05:53:19.000Z</published>
    <updated>2022-08-15T06:45:13.173Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是懒加载？"><a href="#1-什么是懒加载？" class="headerlink" title="1.什么是懒加载？"></a>1.什么是懒加载？</h3><p>懒加载也就是延迟加载。<br>当访问一个页面的时候，先把img元素或是其他元素的背景图片路径替换成一张大小为1*1px图片的路径（这样就只需请求一次，俗称占<a href="https://so.csdn.net/so/search?q=%E4%BD%8D%E5%9B%BE&spm=1001.2101.3001.7020">位图</a>），只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。这就是图片懒加载。</p><h3 id="2-为什么要使用懒加载？"><a href="#2-为什么要使用懒加载？" class="headerlink" title="2.为什么要使用懒加载？"></a>2.为什么要使用懒加载？</h3><p>很多页面，内容很丰富，页面很长，图片较多。比如说各种商城页面。这些页面图片数量多，而且比较大，少说百来K，多则上兆。要是页面载入就一次性加载完毕。估计大家都会等到黄花变成黄花菜了。</p><h3 id="3-懒加载的原理是什么？"><a href="#3-懒加载的原理是什么？" class="headerlink" title="3.懒加载的原理是什么？"></a>3.懒加载的原理是什么？</h3><p>页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片，只有通过javascript设置了图片路径，浏览器才会发送请求。<br>懒加载的原理就是先在页面中把所有的图片统一使用一张占位图进行占位，把正真的路径存在元素的“data-url”（这个名字起个自己认识好记的就行）属性里，要用的时候就取出来，再设置；</p><h3 id="4-懒加载的实现步骤？"><a href="#4-懒加载的实现步骤？" class="headerlink" title="4.懒加载的实现步骤？"></a>4.懒加载的实现步骤？</h3><p>1)首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。<br>2)页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。<br>3)在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。</p><h3 id="5-懒加载的优点是什么？"><a href="#5-懒加载的优点是什么？" class="headerlink" title="5.懒加载的优点是什么？"></a>5.懒加载的优点是什么？</h3><p>页面加载速度快、可以减轻服务器的压力、节约了流量,用户体验好</p><p>&#x2F;&#x2F;懒加载代码实现<br>var viewHeight &#x3D; document.documentElement.clientHeight &#x2F;&#x2F; 可视区域的高度</p><p>function lazyload () {<br>&#x2F;&#x2F; 获取所有要进行懒加载的图片<br>var eles &#x3D; document.querySelectorAll(‘img[data-original][lazyload]’)<br>Array.prototype.forEach.call(eles, function (item, index) {<br>var rect<br>if (item.dataset.original &#x3D;&#x3D;&#x3D; ‘’)<br>return<br>rect &#x3D; item.getBoundingClientRect()<br>&#x2F;&#x2F; 图片一进入可视区，动态加载<br>if (rect.bottom &gt;&#x3D; 0 &amp;&amp; rect.top &lt; viewHeight) {<br>!function () {<br>var img &#x3D; new Image()<br>img.src &#x3D; item.dataset.original<br>img.onload &#x3D; function () {<br>item.src &#x3D; img.src<br>}<br>item.removeAttribute(‘data-original’)<br>item.removeAttribute(‘lazyload’)<br>}()<br>}<br>})<br>}<br>&#x2F;&#x2F; 首屏要人为的调用，否则刚进入页面不显示图片<br>lazyload()</p><p>document.addEventListener(‘scroll’, lazyload)</p><h3 id="预加载的核心要点如下："><a href="#预加载的核心要点如下：" class="headerlink" title="预加载的核心要点如下："></a>预加载的核心要点如下：</h3><ul><li><p>1.图片等静态资源在使用之前的提前请求；</p></li><li><p>2.资源后续使用时可以从缓存中加载，提升用户体验；</p></li><li><p>3.页面展示的依赖关系维护（必需的资源加载完才可以展示页面，防止白屏等）；</p></li></ul><h4 id="实现预加载主要有三个方法："><a href="#实现预加载主要有三个方法：" class="headerlink" title="实现预加载主要有三个方法："></a>实现预加载主要有三个方法：</h4><p>1.html中img标签最初设置为display:none；</p><p>2.js脚本中使用image对象动态创建好图片；</p><p>3.使用XMLHttpRequest对象可以更加精细的控制预加载过程，缺点是无法跨域：</p><h3 id="1-什么是预加载？"><a href="#1-什么是预加载？" class="headerlink" title="1.什么是预加载？"></a>1.什么是预加载？</h3><p>提前加载图片，当用户需要查看时可直接从本地缓存中渲染</p><h3 id="2-为什么要使用预加载？"><a href="#2-为什么要使用预加载？" class="headerlink" title="2.为什么要使用预加载？"></a>2.为什么要使用预加载？</h3><p>图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。</p><h3 id="3-实现预加载的方法有哪些？"><a href="#3-实现预加载的方法有哪些？" class="headerlink" title="3.实现预加载的方法有哪些？"></a>3.实现预加载的方法有哪些？</h3><p>方法一：用CSS和JavaScript实现预加载<br>方法二：仅使用JavaScript实现预加载<br>方法三：使用Ajax实现预加载</p><h3 id="3、懒加载和预加载的对比"><a href="#3、懒加载和预加载的对比" class="headerlink" title="3、懒加载和预加载的对比"></a>3、懒加载和预加载的对比</h3><p><strong>1)概念</strong>：</p><p>懒加载也叫延迟加载：JS图片延迟加载,延迟加载图片或符合某些条件时才加载某些图片。<br>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</p><p><strong>2)区别：</strong></p><p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p><h4 id="3-懒加载的意义及实现方式有："><a href="#3-懒加载的意义及实现方式有：" class="headerlink" title="3)懒加载的意义及实现方式有："></a>3)懒加载的意义及实现方式有：</h4><p><strong>意义：</strong><br>懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。<br><strong>实现方式：</strong><br>1.第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟.<br>2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。<br>3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。</p><h4 id="4-预加载的意义及实现方式有："><a href="#4-预加载的意义及实现方式有：" class="headerlink" title="4)预加载的意义及实现方式有："></a>4)预加载的意义及实现方式有：</h4><p><strong>意义:</strong><br>预加载可以说是牺牲服务器前端性能，换取更好的用户体验，这样可以使用户的操作得到最快的反映。<br><strong>实现方式：</strong><br>实现预载的方法非常多，比如：用CSS和JavaScript实现预加载；仅使用JavaScript实现预加载；使用Ajax实现预加载。<br>常用的是new Image();设置其src来实现预载，再使用onload方法回调预载完成事件。只要浏览器把图片下载到本地，同样的src就会使用缓存，这是最基本也是最实用的预载方法。当Image下载完图片头后，会得到宽和高，因此可以在预载前得到图片的大小(方法是用记时器轮循宽高变化)。</p><h3 id="4、补充知识"><a href="#4、补充知识" class="headerlink" title="4、补充知识"></a>4、补充知识</h3><h4 id="屏幕可视窗口大小"><a href="#屏幕可视窗口大小" class="headerlink" title="屏幕可视窗口大小"></a>屏幕可视窗口大小</h4><p>原生方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> window.innerHeight 标准浏览器及IE9+ || </span><br><span class="line"></span><br><span class="line"> document.documentElement.clientHeight 标准浏览器及低版本IE标准模式 || </span><br><span class="line"></span><br><span class="line"> document.body.clientHeight  低版本混杂模式 </span><br><span class="line"></span><br><span class="line">jQuery方法：  </span><br><span class="line"></span><br><span class="line">    $(window).height();</span><br></pre></td></tr></table></figure><p>浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离：</p><p>原生方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      window.pagYoffset 标准浏览器及IE9+ || </span><br><span class="line"></span><br><span class="line">      document.documentElement.scrollTop 兼容ie低版本的标准模式 || </span><br><span class="line"></span><br><span class="line">      document.body.scrollTop 兼容混杂模式； </span><br><span class="line"></span><br><span class="line">jQuery方法： </span><br><span class="line"></span><br><span class="line">      $(document).scrollTop()</span><br></pre></td></tr></table></figure><h4 id="获取元素的尺寸"><a href="#获取元素的尺寸" class="headerlink" title="获取元素的尺寸"></a>获取元素的尺寸</h4><p>$(o).width() &#x3D; o.style.width;<br>$(o).innerWidth() &#x3D; o.style.width+o.style.padding;<br>$(o).outerWidth() &#x3D; o.offsetWidth &#x3D; o.style.width+o.style.padding+o.style.border；<br>$(o).outerWidth(true) &#x3D; o.style.width+o.style.padding+o.style.border+o.style.margin；</p><p>注意<br>要使用原生的style.xxx方法获取属性，这个元素必须已经有内嵌的样<br>如果原先是通过外部或内部样式表定义css样式，必须使用o.currentStyle[xxx] || document.defaultView.getComputedStyle(0)[xxx]来获取样式值。</p>]]></content>
    
    
    <summary type="html">图片懒加载和预加载的区别</summary>
    
    
    
    <category term="Html" scheme="http://example.com/categories/Html/"/>
    
    
    <category term="-Html" scheme="http://example.com/tags/Html/"/>
    
  </entry>
  
  <entry>
    <title>常用的hook</title>
    <link href="http://example.com/2021/06/25/React/%E5%B8%B8%E7%94%A8%E7%9A%84hook/"/>
    <id>http://example.com/2021/06/25/React/%E5%B8%B8%E7%94%A8%E7%9A%84hook/</id>
    <published>2021-06-25T02:50:39.000Z</published>
    <updated>2022-08-10T02:04:09.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p>示例：</p><p>const [stateA, setStateA] &#x3D; useState(0)</p><p>参数是初始state（定义初始state最好给出初始值，方便后期维护， 0&#x2F;false&#x2F;’’&#x2F;[]&#x2F;{}）。</p><p>返回值：一个是当前state，一个是更新state的函数。</p><p>useState的实现很简单，只有两行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export function useState&lt;S&gt;(initialState: (() =&gt; S) | S) &#123;</span><br><span class="line">  const dispatcher = resolveDispatcher();</span><br><span class="line">  return dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点都在dispatcher上，dispatcher通过resolveDispatcher()来获取，这个函数只是将ReactCurrentDispatcher.current的值赋给了dispatcher</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function resolveDispatcher() &#123;</span><br><span class="line">  const dispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">  return dispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useState挂在dispatcher上，resolveDispatcher() 返回的是 ReactCurrentDispatcher.current，所以useState(xxx)等价于ReactCurrentDispatcher.current.useState(xxx)。<br>简单理解：</p><blockquote><p> 初次渲染的时候，按照 useState，useEffect 的顺序，把 state，deps 等按顺序塞到 memoizedState 数组中，共享同一个 memoizedState，共享同一个顺序。<br>更新的时候，按照顺序，从 memoizedState 中把上次记录的值拿出来。</p></blockquote><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>useEffect的实现很简单，也是只有两行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export function useEffect (create: () = &gt;(() = &gt;void) | void, deps: Array &lt; mixed &gt; |void | null, ) : void &#123;</span><br><span class="line">  const dispatcher = resolveDispatcher();</span><br><span class="line">  return dispatcher.useEffect(create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useEffect产生的hook会放在fiber.memoizedState上，调用后生成一个effect对象，存储到对应hook的memoizedState中，与其他effect连接成环形链表。<br>单个的effect对象包含以下几个属性：<br>create：传入useEffect函数的第一个参数，即回调函数；<br>destory：回调函数中的return函数，在改effect销毁的时候执行，默认发生在第一次渲染后，也可以让它在依赖项数组中的值改变时执行，通过return清除副作用函数（如监听、订阅、计时器等）；<br>deps：依赖项，传入的第二个参数，用来控制该Effect包裹的函数执不执行。如果依赖项为空数组[]，则该Effect在每次组件挂载时执行，且仅执行一次，相当于class组件中的componentDidMount和componentDidupdate生命周期的融合；如果没有第二个参数，则effect会不停地调用。<br>next：指向下一个effect；<br>tag：effect的类型，区分useEffect和useLayoputEffect。<br>hook会挂载到fiber.memoizedState上。hook按出现顺序进行存储，memoizedState存储了useEffect的effect对象（effect1），next指向useLayoutEffect的effect对象（effect2），effect2的next又会指向effect1，最终形成闭环。结构如下：<br><img src="https://img-blog.csdnimg.cn/20210524181825618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwOTk3NTAz,size_16,color_FFFFFF,t_70"></p><p>结论：effect在页面完成渲染后按照先后顺序执行，并且内部执行时异步的</p><blockquote><p>useEffect和useLayoutEffect：<br>useLayoutEffect也是一个hook方法，跟useEffect类似，区别在于渲染时机不同，useEffect发生在浏览器渲染结束后执行，useLayoutEffect则是发生在dom更新完成后。</p></blockquote><h4 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h4><p>useLayoutEffect和useEffect很像，唯一的不同点就是useEffect是异步执行，而useLayoutEffect是同步执行的。</p><p>当函数组件刷新（渲染）时，</p><p>包含useEffect的组件整个运行过程如下：<br>1、触发组件重新渲染（通过改变组件state或者组件的父组件重新渲染，导致子节点渲染）<br>2、组件函数执行<br>3、组件渲染后呈现到屏幕上<br>4、useEffect hook执行</p><p>包含useLayoutEffect的组件整个运行过程如下：<br>1、触发组件重新渲染（通过改变组件state或者组件的父组件重新渲染，导致子组件渲染）<br>2、组件函数执行<br>3、useLayoutEffect hook执行, React等待useLayoutEffect的函数执行完毕<br>4、组件渲染后呈现到屏幕上</p><p>useEffect异步执行的优点是，react渲染组件不必等待useEffect函数执行完毕，造成阻塞。</p><p>百分之99的情况，使用useEffect就可以了，唯一需要用到useLayoutEffect的情况就是，在使用useEffect的情况下，我们的屏幕会出现闪烁的情况（组件在很短的时间内渲染了两次）。</p><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p>参数：第一个是reducer纯函数，第二个是初始state，第三个是修改初始state，用于重置<br>返回值是一个数组，数组第一个元素是state的当前值，第二个元素是发送action的dispatch函数</p><blockquote><p>结论：useReducer可以处理多个用useState实现的逻辑（加载状态、错误信息、请求数据）</p></blockquote><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p>参数是创建函数和依赖项数组。</p><p>返回值是一个带有memoized的值，发生在render之前， 并且这个值仅在依赖项改变时才重新计算。</p><blockquote><p>结论：useMemo发生在render前，返回一个缓存的数据，且仅在依赖项改变后变化。</p><p>使用useMemo可以避免多余的计算开销。</p></blockquote><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>参数是内联回调函数和依赖项数组，</p><p>返回值是回调函数的memoized版，该回调函数仅在某个依赖项改变时才会更新。</p><blockquote><p>结论：返回一个缓存的函数，添加依赖项数组可以避免函数的无意义计算，降低了子组件的渲染开销。</p></blockquote><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>返回值是一个可变的ref对象，并且这个对象的值发生改变时不会引起页面的渲染。</p><blockquote><p>结论：useRef可以存储不需要引起页面渲染的数据；修改useRef值的唯一方法是修改.current，且修改后不会引起重渲染。</p></blockquote><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><p>跨组件共享数据的钩子函数，接收一个context对象，并返回该对象的当前值。</p><p>当前的context值由上层组件中距离当前组件最近的&lt;MyContext.Provider&gt;的value决定，并且父组件的context发生改变是，子组件都会重新渲染。</p><blockquote><p>结论：useContext会在context值变化时重新渲染，&lt;MyContext.Provider&gt;的value发生变化时，包裹的组件无论是否订阅value值，都会重新渲染，可以使用memo对未使用value的子组件进行优化。</p></blockquote>]]></content>
    
    
    <summary type="html">React中常用的hook</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="-React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>类组件和函数组件的区别</title>
    <link href="http://example.com/2021/06/25/React/%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/06/25/React/%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-06-25T02:50:39.000Z</published>
    <updated>2022-08-11T06:33:55.166Z</updated>
    
    
    <summary type="html">类组件和函数组件的区别</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="-React" scheme="http://example.com/tags/React/"/>
    
    <category term="-component" scheme="http://example.com/tags/component/"/>
    
  </entry>
  
  <entry>
    <title>React中的hooks是什么</title>
    <link href="http://example.com/2021/06/17/React/React%E4%B8%AD%E7%9A%84hooks/"/>
    <id>http://example.com/2021/06/17/React/React%E4%B8%AD%E7%9A%84hooks/</id>
    <published>2021-06-17T02:50:39.000Z</published>
    <updated>2022-08-10T01:27:41.025Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么用hook"><a href="#为什么用hook" class="headerlink" title="为什么用hook"></a>为什么用hook</h3><p>在react类组件（class）写法中，有setState和生命周期对状态进行管理，但是在函数组件中不存在这些，故引入hooks（版本：**&gt;&#x3D;16.8**），使开发者在非class的情况下使用更多react特性。</p><p>以下是实现一个输入框，类组件和函<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>件两种写法的对比：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @name 类组件</span><br><span class="line"> */</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">export default class Home extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name: &#x27;world&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    console.log(&#x27;组件挂载后要做的操作&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    console.log(&#x27;组件卸载要做的操作&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">    if (prevState.name !== this.state.name) &#123;</span><br><span class="line">      console.log(&#x27;组件更新后的操作&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;hello &#123;this.state.name&#125;&lt;/p&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; placeholder=&quot;input new name&quot;</span><br><span class="line">          onChange=&#123;(e) =&gt; this.setState(&#123; name: e.target.value &#125;)&#125;&gt;</span><br><span class="line">        &lt;/input&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @name 函数组件</span><br><span class="line"> */</span><br><span class="line">import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function Home() &#123;</span><br><span class="line">  const [name, setName] = useState(&#x27;world&#x27;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;hello &#123;name&#125;&lt;/p&gt;</span><br><span class="line">      &lt;DemoState /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function DemoState() &#123;</span><br><span class="line">  const [n1, setN1] = useState(1)</span><br><span class="line">  const [n2, setN2] = useState(2)</span><br><span class="line">  const [n3, setN3] = useState(3)</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    setN1(10)</span><br><span class="line">    setN1(100)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  const handleClick = () =&gt; &#123;</span><br><span class="line">    setN2(20)</span><br><span class="line">    setN3(30)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;demo-state&#x27;, n1, n2, n3)</span><br><span class="line">  return &lt;button onClick=&#123;handleClick&#125;&gt;click&lt;/button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中，useState相当于constructor，完成数据的初始化；</p><p>useEffect相当于componentDidMount和componentDidUpdate两个生命周期，通过return () &#x3D;&gt; {}的方式解绑生命周期，相当于componentWillUnmount周期，以监听页面滚动为例，通过effect实现监听与解绑如下：</p><p>useEffect(() &#x3D; &gt;{<br>window.addEventListener(‘scroll’, throttleFunc)<br>return () &#x3D; &gt;{<br>window.removeEventListener(‘scroll’, throttleFunc)<br>}<br>}, [])</p><p>在同一个effect钩子中实现绑定与解绑，使状态的管理更加方便、代码更简洁。</p><p>此外还有发生在页面渲染前的useMemo相当于shouldComponentUpdate周期等，具体关系如下表：</p><table><thead><tr><th>class组件</th><th>hooks</th></tr></thead><tbody><tr><td>shouldComponentUpdate</td><td>useMemo</td></tr><tr><td>render</td><td>函数本身</td></tr><tr><td>getDerivedStateFromProps</td><td>useState 中的 update</td></tr><tr><td>getDerivedStateFromError</td><td>无</td></tr><tr><td>constructor</td><td>useState</td></tr><tr><td>componentWillUnmount</td><td>useEffect中的return函数</td></tr><tr><td>componentDidUpdate</td><td>useEffect</td></tr><tr><td>componentDidMount</td><td>useEffect</td></tr><tr><td>componentDidCatch</td><td>无</td></tr></tbody></table><h3 id="什么是hook"><a href="#什么是hook" class="headerlink" title="什么是hook"></a>什么是hook</h3><p>hooks挂载在Fiber结点上的memoizedState，filber结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FiberNode &#123; // fiber结构</span><br><span class="line">  memoziedState, // 组件更新的依据</span><br><span class="line">  type, // 原生或react   </span><br><span class="line">  key,</span><br><span class="line">  tag,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>memoziedState这个字段很重要，是组件更新的唯一依据。在class组件里，它就是this.state的结构，调用this.setState的时候，其实就是修改了它的数据，数据改变了组件就会重新执行。</p><p>也就是说，即使是class组件，也不会主动调用任何生命周期函数，而是在memoziedState改变后，组件重新执行，在执行的过程中才会经过这些周期。</p><p>所以，这就解释了函数式组件为什么可以通过hooks改变状态，实际上就是修改了对应fiber节点的memoziedState。</p><p>hooks主要有以下特点：</p><p>1、无需修改组件结构的情况下复用状态逻辑；</p><p>2、可将组件中相互关联的部分拆分成更小的函数，复杂组件将变得更容易理解；</p><p>3、每一个组件内的函数(包括事件处理函数，effects，定时器或者api调用等等)会捕获某次渲染中定义的props和state；</p><p>4、memo缓存组件 ,useMemo缓存值， useCallback缓存函数；</p><p>5、每次render都有自己的props、state和effects。(每一个组件内的函数，包括事件处理函数，effects，定时器或者api调用等等，会捕获某次渲染中定义的props和state)；</p><p>6、<strong>更新状态的时候(如setCount(count + 1))，React会重新渲染组件，</strong>每一次渲染都能拿到独立的count状态，这个状态值是函数中的一个常量；</p><p>7、没有了显性的生命周期，所有渲染后的执行方法都在useEffect里面统一管理；</p><p>8、函数式编程，不需要定义constructor、render、class；</p><p>9、某一个组件，方法需不需要渲染、重新执行完全取决于开发者，方便管理。</p><h3 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h3><ul><li><p>有时候我们需要重复使用一些状态逻辑，怎么处理可以在不增加组件的前提下实现复用，自定义hook可以达到这一目的。</p></li><li><p>通过自定义hook，抽取多个组件重复使用的逻辑，将这些重复的逻辑添加到一个叫做useSomething的自定义hook中，调用这一hook达到逻辑复用的目的，在不增加组件的情况下实现了逻辑共享。</p></li><li><p>自定义的hook是一个函数，名称以“use”开头，函数内部可用调用其他hook</p></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>hook主要从以下三个方面对函数式组件进行优化：</p><ul><li>useCallback用于缓存函数</li><li>useMemo用于缓存计算结果，简单理解useCallback(fn, deps) &#x3D;&#x3D;&#x3D; useMemo(() &#x3D;&gt; fn, deps)</li><li>useReducer用于处理多状态的state</li></ul><blockquote><p>优化本身也会带来大量的计算，无意义的优化反而会增加额外的开销。所以优化需谨慎。</p></blockquote>]]></content>
    
    
    <summary type="html">React中的hooks是什么</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="-React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Vue3为什么采用 Composition API.md</title>
    <link href="http://example.com/2021/06/03/Vue3/Vue3%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8Composition%20API/"/>
    <id>http://example.com/2021/06/03/Vue3/Vue3%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8Composition%20API/</id>
    <published>2021-06-03T09:03:26.000Z</published>
    <updated>2022-08-17T09:16:37.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>Composition API 可以说是Vue3的最大特点，那么为什么要推出Composition Api，解决了什么问题？</p><p>通常使用Vue2开发的项目，普遍会存在以下问题：</p><p>代码的可读性随着组件变大而变差<br>每一种代码复用的方式，都存在缺点<br>TypeScript支持有限<br>以上通过使用Composition Api都能迎刃而解</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h3 id="一、Options-Api"><a href="#一、Options-Api" class="headerlink" title="一、Options Api"></a>一、Options Api</h3><p>Options API，即大家常说的选项API，即以vue为后缀的文件，通过定义methods，computed，watch，data等属性与方法，共同处理页面逻辑</p><p>如下图：<br><img src="https://static.vue-js.com/9bf6d9d0-6048-11eb-85f6-6fac77c0c9b3.png"></p><p>可以看到Options代码编写方式，如果是组件状态，则写在data属性上，如果是方法，则写在methods属性上…</p><p>用组件的选项 (data、computed、methods、watch) 组织逻辑在大多数情况下都有效</p><p>然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解</p><h3 id="二、Composition-Api"><a href="#二、Composition-Api" class="headerlink" title="二、Composition Api"></a>二、Composition Api</h3><p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p><p>即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API<br><img src="https://static.vue-js.com/acee9200-6048-11eb-ab90-d9ae814b240d.png"></p><h3 id="三、对比"><a href="#三、对比" class="headerlink" title="三、对比"></a>三、对比</h3><p>下面对Composition Api与Options Api进行两大方面的比较</p><ul><li>逻辑组织</li><li>逻辑复用</li></ul><h4 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h4><h5 id="Options-API"><a href="#Options-API" class="headerlink" title="Options API"></a>Options API</h5><p>假设一个组件是一个大型组件，其内部有很多处理逻辑关注点,这种碎片化使得理解和维护复杂组件变得困难<br>选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块</p><h5 id="Compostion-API"><a href="#Compostion-API" class="headerlink" title="Compostion API"></a>Compostion API</h5><p>而Compositon API正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去</p><p>下面举个简单例子，将处理count属性相关的代码放在同一个函数了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function useCount() &#123;</span><br><span class="line">    let count = ref(10);</span><br><span class="line">    let double = computed(() =&gt; &#123;</span><br><span class="line">        return count.value * 2;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const handleConut = () =&gt; &#123;</span><br><span class="line">        count.value = count.value * 2;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    console.log(count);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        count,</span><br><span class="line">        double,</span><br><span class="line">        handleConut,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件上中使用count</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default defineComponent(&#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const &#123; count, double, handleConut &#125; = useCount();</span><br><span class="line">        return &#123;</span><br><span class="line">            count,</span><br><span class="line">            double,</span><br><span class="line">            handleConut</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再来一张图进行对比，可以很直观地感受到 Composition API在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可</p><h4 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h4><p>在Vue2中，我们是用过mixin去复用相同的逻辑</p><p>下面举个例子，我们会另起一个mixin.js文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">export const MoveMixin = &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleKeyup(e) &#123;</span><br><span class="line">      console.log(e.code);</span><br><span class="line">      // 上下左右 x y</span><br><span class="line">      switch (e.code) &#123;</span><br><span class="line">        case &quot;ArrowUp&quot;:</span><br><span class="line">          this.y--;</span><br><span class="line">          break;</span><br><span class="line">        case &quot;ArrowDown&quot;:</span><br><span class="line">          this.y++;</span><br><span class="line">          break;</span><br><span class="line">        case &quot;ArrowLeft&quot;:</span><br><span class="line">          this.x--;</span><br><span class="line">          break;</span><br><span class="line">        case &quot;ArrowRight&quot;:</span><br><span class="line">          this.x++;</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted() &#123;</span><br><span class="line">    window.addEventListener(&quot;keyup&quot;, this.handleKeyup);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  unmounted() &#123;</span><br><span class="line">    window.removeEventListener(&quot;keyup&quot;, this.handleKeyup);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在组件中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import mousePositionMixin from &#x27;./mouse&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  mixins: [mousePositionMixin]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>使用单个mixin似乎问题不大，但是当我们一个组件混入大量不同的 mixins 的时候</p><p>mixins: [mousePositionMixin, fooMixin, barMixin, otherMixin]<br>会存在两个非常明显的问题：</p><p>命名冲突<br>数据来源不清晰<br>现在通过Compositon API这种方式改写上面的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import &#123; onMounted, onUnmounted, reactive &#125; from &quot;vue&quot;;</span><br><span class="line">export function useMove() &#123;</span><br><span class="line">  const position = reactive(&#123;</span><br><span class="line">    x: 0,</span><br><span class="line">    y: 0,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const handleKeyup = (e) =&gt; &#123;</span><br><span class="line">    console.log(e.code);</span><br><span class="line">    // 上下左右 x y</span><br><span class="line">    switch (e.code) &#123;</span><br><span class="line">      case &quot;ArrowUp&quot;:</span><br><span class="line">        // y.value--;</span><br><span class="line">        position.y--;</span><br><span class="line">        break;</span><br><span class="line">      case &quot;ArrowDown&quot;:</span><br><span class="line">        // y.value++;</span><br><span class="line">        position.y++;</span><br><span class="line">        break;</span><br><span class="line">      case &quot;ArrowLeft&quot;:</span><br><span class="line">        // x.value--;</span><br><span class="line">        position.x--;</span><br><span class="line">        break;</span><br><span class="line">      case &quot;ArrowRight&quot;:</span><br><span class="line">        // x.value++;</span><br><span class="line">        position.x++;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  onMounted(() =&gt; &#123;</span><br><span class="line">    window.addEventListener(&quot;keyup&quot;, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  onUnmounted(() =&gt; &#123;</span><br><span class="line">    window.removeEventListener(&quot;keyup&quot;, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return &#123; position &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; useMove &#125; from &quot;./useMove&quot;;</span><br><span class="line">import &#123; toRefs &#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const &#123; position &#125; = useMove();</span><br><span class="line">    const &#123; x, y &#125; = toRefs(position);</span><br><span class="line">    return &#123;</span><br><span class="line">      x,</span><br><span class="line">      y,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在逻辑组织和逻辑复用方面，Composition API是优于Options API<br>因为Composition API几乎是函数，会有更好的类型推断。<br>Composition API对 tree-shaking 友好，代码也更容易压缩<br>Composition API中见不到this的使用，减少了this指向不明的情况<br>如果是小型组件，可以继续使用Options API，也是十分友好的</p>]]></content>
    
    
    <summary type="html">title:VUE3Vue3为什么采用 Composition API.md</summary>
    
    
    
    <category term="Vue3" scheme="http://example.com/categories/Vue3/"/>
    
    
    <category term="-Vue3" scheme="http://example.com/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3.0和Vue2.0的区别</title>
    <link href="http://example.com/2021/05/09/Vue3/Vue3.0%E5%92%8CVue2.0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/05/09/Vue3/Vue3.0%E5%92%8CVue2.0%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-05-09T03:12:26.000Z</published>
    <updated>2022-08-11T09:30:01.534Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、vue2的响应式-vs-vue3的响应式-性能提升"><a href="#1、vue2的响应式-vs-vue3的响应式-性能提升" class="headerlink" title="1、vue2的响应式 vs vue3的响应式 (性能提升)"></a>1、vue2的响应式 vs vue3的响应式 (性能提升)</h3><p><strong>响应式系统升级</strong></p><ul><li>vue2 中的 object.defineProperty(响应式系统的核心)</li></ul><blockquote><p>初始化的时候，会遍历data中的所有成员，使用defineProperty把对象的属性转换成get和set，如果该成员中的属性还是对象的话，需要递归处理每一个子对象的属性。这些都是在初始化的时候进行的。即使你没有使用到这个属性，那么也是会将该属性进行响应式处理。</p></blockquote><ul><li>vue3 proxy</li></ul><blockquote><p>proxy的性能本身就比defineProperty要好， 另外，代理对象可以拦截属性的访问、赋值、删除等操作，不需要初始化时遍历所有的属性。另外，如果有多层属性嵌套的话，只有访问某个属性的时候，才会递归处理下一级的属性。使用proxy默认就可以监听到动态新增的属性，可以监听到删除的属性。可以监听数组的索引和length属性。<br>总结： vue3使用的proxy对象提升了响应式系统的性能和功能</p></blockquote><h3 id="2、模板语法"><a href="#2、模板语法" class="headerlink" title="2、模板语法"></a>2、模板语法</h3><p>打开App.vue文件，唯一和Vue2不同的是：Template不再强调一定要有根标签了。</p><h3 id="3、生命周期函数对比"><a href="#3、生命周期函数对比" class="headerlink" title="3、生命周期函数对比"></a>3、生命周期函数对比</h3><h4 id="1）首先需要了解生命周期是什么？"><a href="#1）首先需要了解生命周期是什么？" class="headerlink" title="1）首先需要了解生命周期是什么？"></a>1）首先需要了解生命周期是什么？</h4><blockquote><p>Vue实例从创建到销毁的过程，就是Vue实例的生命周期。</p></blockquote><blockquote><p>这个过程包括数据监听、编译模板、将实例挂载到DOM并在数据变化时更新DOM等。</p></blockquote><h4 id="2）-具体含义和实际项目中的意义："><a href="#2）-具体含义和实际项目中的意义：" class="headerlink" title="2） 具体含义和实际项目中的意义："></a>2） 具体含义和实际项目中的意义：</h4><p><strong>vue3中各个生命周期函数的意义</strong></p><blockquote><p>setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method<br>onBeforeMount() : 组件挂载到节点上之前执行的函数。<br>onMounted() : 组件挂载完成后执行的函数。<br>onBeforeUpdate(): 组件更新之前执行的函数。<br>onUpdated(): 组件更新完成之后执行的函数。<br>onBeforeUnmount(): 组件卸载之前执行的函数。<br>onUnmounted(): 组件卸载完成后执行的函数<br>onActivated(): 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行。<br>onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行。<br>onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数。<br>vue2中各个生命周期函数的意义</p></blockquote><ul><li><p>beforeCreate():实例在内存中被创建出来，还没有初始化好data和methods属性。</p></li><li><p>create():实例已经在内存中创建，已经初始化好data和method，此时还没有开始编译模板。</p></li><li><p>beforeMount():已经完成了模板的编译，还没有挂载到页面中。</p></li><li><p>mounted()：将编译好的模板挂载到页面指定的容器中显示。</p></li><li><p>beforeUpdate():状态更新之前执行函数，此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为还没有开始重新渲染DOM节点。</p></li><li><p>updated():此时data中的状态值和界面上显示的数据都已经完成了跟新，界面已经被重新渲染好了！</p></li><li><p>beforeDestroy():实例被销毁之前。</p></li><li><p>destroyed():实例销毁后调用，Vue实例指示的所有东西都会解绑，所有的事件监听器都会被移除,所有的子实例也都会被销毁。组件已经被完全销毁，此时组建中所有data、methods、以及过滤器，指令等，都已经不可用了。</p></li></ul><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3)总结"></a>3)总结</h4><blockquote><p>Vue3相比原有的生命周期，基本都是存在的，Vue3只不过有了新的命名：beforeDestroy变成了onbeforeUnmount；destroy变成了onUnmounted，名字变了但是原理还是没变的；</p></blockquote><h3 id="4、重要的setup函数"><a href="#4、重要的setup函数" class="headerlink" title="4、重要的setup函数"></a>4、重要的setup函数</h3><p>在vue2中我们js部分是data、methods、computed等等，但是在vue3中都是在setup上,setup函数可以说是Vue3的属性和方法入口</p><p> setup函数中有以下几个特点：</p><p>1）setup(props,context):接收两个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1) props ：接收来自父组件传来的参数</span><br><span class="line"> </span><br><span class="line">(2) context ：上下文，主要包含3个使用参数：attrs,emits,slots，相当于Vue2中this的 </span><br><span class="line">attrs,emits,slots</span><br></pre></td></tr></table></figure><p>2）有返回值，返回值可以是两种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) 返回 对象 ，返回的对象中的属性方法，可在模板中直接使用；</span><br><span class="line"> </span><br><span class="line">(2) 返回 渲染函数 ，可以自定义渲染的内容；</span><br></pre></td></tr></table></figure><p>3）函数内部没有this；</p><p>4）当内部有异步函数，需要使用到await的时候，可以直接使用，不需要在setup前面加async；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//最基础的写法</span><br><span class="line">import &#123; h &#125; from &#x27;vue&#x27;</span><br><span class="line">setup() &#123;</span><br><span class="line">    let name = &#x27;连颜少&#x27;;</span><br><span class="line">    let age = 18;</span><br><span class="line"> </span><br><span class="line">    function sayhello() &#123;</span><br><span class="line">      alert(`我叫$&#123;name&#125;,我每年都$&#123;age&#125;.你好`)</span><br><span class="line">    &#125;</span><br><span class="line">    function changeInfo() &#123;</span><br><span class="line">      name = &#x27;new 连颜少&#x27;;</span><br><span class="line">      age = 28;</span><br><span class="line">      console.log(name,age);</span><br><span class="line">    &#125;</span><br><span class="line">    // 1.返回对象</span><br><span class="line">    return &#123;</span><br><span class="line">      name,age,sayhello,changeInfo</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.返回渲染函数</span><br><span class="line">    // return ()=&gt; h(&#x27;h1&#x27;,name)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>5）如果想要实现双向数据绑定原理，需要通过ref定义变量来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const value = ref&lt;string&gt;(&quot;&quot;)</span><br></pre></td></tr></table></figure><p>6）vue3中是组合式API，就是将所有的业务逻辑放在了一个地方进行处理，增强了代码的可读性和逻辑复用性。以下便是vue2和vue3的业务逻辑使用实际做一个对比，如下</p><p>以下内容同一个色块代表同一块业务逻辑</p><p>vue2中业务逻辑没有放在一起</p><p>各个业务逻辑的代码互相穿插，我们需要不断地跳转到相应模块代码进行逻辑处理，这使得组件的代码理解和维护越来越难。</p><p>为了解决这个问题，Vue3引入了组合式API，将同一个逻辑关注点的代码配置在一起，增强代码的可读性和可维护性，这也是Vue3引入组合式API的主要目的。</p><h3 id="5、v-model双向数据绑定的使用方式不一样，在vue3中我们这样使用"><a href="#5、v-model双向数据绑定的使用方式不一样，在vue3中我们这样使用" class="headerlink" title="5、v-model双向数据绑定的使用方式不一样，在vue3中我们这样使用"></a>5、v-model双向数据绑定的使用方式不一样，在vue3中我们这样使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model:value=&quot;value&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Vue3.0和Vue2.0的区别</summary>
    
    
    
    <category term="Vue3" scheme="http://example.com/categories/Vue3/"/>
    
    
    <category term="-Vue3" scheme="http://example.com/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3中proxy的理解</title>
    <link href="http://example.com/2021/04/21/Vue3/%E6%B5%85%E6%9E%90proxy/"/>
    <id>http://example.com/2021/04/21/Vue3/%E6%B5%85%E6%9E%90proxy/</id>
    <published>2021-04-21T02:20:19.000Z</published>
    <updated>2022-08-10T02:08:20.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么Vue3-x选择使用proxy替换object-defineproperty"><a href="#为什么Vue3-x选择使用proxy替换object-defineproperty" class="headerlink" title="为什么Vue3.x选择使用proxy替换object.defineproperty?"></a>为什么Vue3.x选择使用proxy替换object.defineproperty?</h3><ul><li>vue 的数据劫持有两个缺点</li><li>无法监听通过索引修改数组的值的变化</li><li>无法监听 object 也就是对象的值的变化</li><li>所以 vue2.x 中才会有<code>$set</code> 属性的存在</li><li>proxy 是 es6 中推出的新 api，可以弥补以上两个缺点，所以 vue3.x 版本用 proxy 替换 <code>object.defineproperty</code>。</li></ul><h3 id="Proxy-相比于-defineProperty-的优势"><a href="#Proxy-相比于-defineProperty-的优势" class="headerlink" title="Proxy 相比于 defineProperty 的优势"></a>Proxy 相比于 defineProperty 的优势</h3><ul><li>数组变化也能监听到</li><li>不需要深度遍历监听<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let data = &#123; a: 1 &#125;</span><br><span class="line">let reactiveData = new Proxy(data, &#123;</span><br><span class="line">get: function(target, name)&#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;,</span><br><span class="line">// ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">浅析Vue3中的proxy</summary>
    
    
    
    <category term="Vue3" scheme="http://example.com/categories/Vue3/"/>
    
    
    <category term="-Vue3" scheme="http://example.com/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3生命周期的变化</title>
    <link href="http://example.com/2021/04/19/Vue3/Vue3.0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    <id>http://example.com/2021/04/19/Vue3/Vue3.0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%8F%98%E5%8C%96/</id>
    <published>2021-04-19T09:03:26.000Z</published>
    <updated>2022-08-11T06:10:42.253Z</updated>
    
    <content type="html"><![CDATA[<h3 id="与-2-x-版本生命周期相对应的组合式-API"><a href="#与-2-x-版本生命周期相对应的组合式-API" class="headerlink" title="与 2.x 版本生命周期相对应的组合式 API"></a>与 2.x 版本生命周期相对应的组合式 API</h3><blockquote><p>beforeCreate -&gt; 使用 setup()<br>created -&gt; 使用 setup()<br>beforeMount -&gt; onBeforeMount<br>mounted -&gt; onMounted<br>beforeUpdate -&gt; onBeforeUpdate<br>updated -&gt; onUpdated<br>beforeDestroy -&gt; onBeforeUnmount<br>destroyed -&gt; onUnmounted<br>errorCaptured -&gt; onErrorCaptured</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>msg: &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;update&quot;</span>&gt;</span>更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  ref,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  onMounted,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  onUpdated,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  onUnmounted, </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  onBeforeMount, </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  onBeforeUpdate,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  onBeforeUnmount</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  beforeCreate () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeCreate()&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  created () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;created&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  beforeMount () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeMount&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  mounted () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mounted&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  beforeUpdate () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeUpdate&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  updated () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;updated&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  beforeUnmount () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeUnmount&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  unmounted () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;unmounted&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> msg = <span class="title function_">ref</span>(<span class="string">&#x27;abc&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> <span class="title function_">update</span> = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      msg.<span class="property">value</span> += <span class="string">&#x27;--&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--onBeforeMount&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--onMounted&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">onBeforeUpdate</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--onBeforeUpdate&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">onUpdated</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--onUpdated&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--onBeforeUnmount&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--onUnmounted&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      msg,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      update</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="新增的钩子函数"><a href="#新增的钩子函数" class="headerlink" title="新增的钩子函数"></a>新增的钩子函数</h3><ul><li>onRenderTracked：直译过来就是状态跟踪，它会跟踪页面上所有响应式变量和方法的状态，也就是我们用return返回去的值，它都会跟踪。只要页面有update的情况，它就会跟踪，然后生成一个event对象，我们通过event对象来查找程序的问题所在。</li><li>引用进来，在 setup() 中使用即可</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onRenderTracked((event) =&gt; &#123;</span><br><span class="line">  console.log(&quot;状态跟踪组件-----------&gt;&quot;);</span><br><span class="line">  console.log(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>onRenderTriggered：直译过来是状态触发，它不会跟踪每一个值，而是给你变化值的信息，并且新值和旧值都会给你明确的展示出来</li><li>使用的时候依然要先引入</li><li>在使用onRenderTriggered前，记得注释相应的onRenderTracked代码，这样看起来会直观很多。 然后把onRenderTriggered()函数，写在setup()函数里边</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onRenderTriggered((event) =&gt; &#123;</span><br><span class="line">  console.log(&quot;状态触发组件---------------&gt;&quot;);</span><br><span class="line">  console.log(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>属性介绍</strong></p><ul><li>key：那边变量发生了变化</li><li>newValue：更新后变量的值</li><li>oldValue：更新前变量的值</li><li>target ：目前页面中的响应变量和函数</li></ul>]]></content>
    
    
    <summary type="html">vue3中生命周期的变化</summary>
    
    
    
    <category term="Vue3" scheme="http://example.com/categories/Vue3/"/>
    
    
    <category term="-生命周期" scheme="http://example.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
    <category term="-Vue3" scheme="http://example.com/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3中通父子组件双向绑定</title>
    <link href="http://example.com/2021/03/26/Vue3/Vue3%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>http://example.com/2021/03/26/Vue3/Vue3%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</id>
    <published>2021-03-26T05:01:40.000Z</published>
    <updated>2022-08-10T02:08:37.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、vue2-中-sync-修饰符的功能在-vue3-中如何呈现？"><a href="#一、vue2-中-sync-修饰符的功能在-vue3-中如何呈现？" class="headerlink" title="一、vue2 中 sync 修饰符的功能在 vue3 中如何呈现？"></a>一、vue2 中 sync 修饰符的功能在 vue3 中如何呈现？</h3><p>1、sync 修饰符回顾</p><blockquote><p>1、vue 规则：props 是单向向下绑定的，子组件不能修改 props 接收过来的外部数据。</p><p>2、如果在子组件中修改 props ，Vue会向你发出一个警告。（无法通过修改子组件的props来更改父组件。）而若需要在子组件更新数据时通知父组件同步更新，需要结合 $emit 和 v-on 实现。</p><p>3、而sync修饰符的作用则是简化事件声明及监听的写法。</p></blockquote><p>　　如下例子，比较sync和正常修改数据通知外层的写法：可以看到 sync 修饰符确实简便了许多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt; 数量： &#123;&#123;num&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;!-- &lt;ChildComponent :num=&quot;num&quot; @increase=&quot;num = $event&quot;/&gt; --&gt;</span><br><span class="line">    &lt;ChildComponent :num.sync=&quot;num&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">//子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div @click=&quot;addNum&quot;&gt; 接收数量： &#123;&#123;num&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    props: [&#x27;num&#x27;],</span><br><span class="line">    // data() &#123;</span><br><span class="line">    //    return &#123;</span><br><span class="line">    //        childNum: this.num</span><br><span class="line">    //    &#125;</span><br><span class="line">    // &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        addNum() &#123;</span><br><span class="line">            // this. childNum++</span><br><span class="line">            // this.$emit(&#x27;increase&#x27;, this. childNum)</span><br><span class="line">            this.$emit(&#x27;update:num&#x27;, this.num + 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、sync 的语法糖功能在vue3中如何编写使用？</strong></p><p>　　vue3 中，<strong>通过 v-model:propName 实现自定义组件间数据的双向绑定</strong>。使用方法：</p><p>（1）父组件通过 “v-model:绑定的属性名” 传递数据属性，支持绑定多个属性；</p><p>（2）子组件配置emits，通过 “update:属性名” 的格式定义更新事件</p><h3 id="二、如何通过v-model实现父子组件的双向数据绑定"><a href="#二、如何通过v-model实现父子组件的双向数据绑定" class="headerlink" title="二、如何通过v-model实现父子组件的双向数据绑定"></a>二、如何通过v-model实现父子组件的双向数据绑定</h3><p>　　Vue3父子组件双向数据绑定写法做了些许改变，同时也支持多个数据双向绑定</p><p>1、<strong>单个数据双向绑定</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">// v-model 没有指定参数名时，子组件默认参数名是modelValue</span><br><span class="line">&lt;ChildComp v-model=&quot;search&quot; /&gt;</span><br></pre></td></tr></table></figure><p>　　需要注意的是：</p><p>（1）子组件也并不是直接拿 props 传的变量直接用，而是需要声明一个响应式变量 - 通过 ref(props.modelValue) 声明基于 props 传的变量值为初始化值的响应式数据。</p><p>（2）且如果父组件传的是异步数据的话，还需要对其进行监听。</p><p>（3）当子组件数据改变时需要通过 emit(‘update:modelValue’, e) 去修改父组件数据实现双向绑定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input v-model=&quot;sea&quot; @input=&quot;valChange(sea)&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref, watch &#125; from &#x27;vue&#x27;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &#x27;ChildComp&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    modelValue: &#123; // 父组件 v-model 没有指定参数名，则默认是 modelValue</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props, &#123; emit &#125;) &#123;</span><br><span class="line">    // input初始化</span><br><span class="line">    const sea = ref(props.modelValue)</span><br><span class="line">    // 如果父组件传过来的数据是异步获取的，则需要进行监听</span><br><span class="line">    watch(() =&gt; props.modelValue, () =&gt; &#123; sea.value = props.modelValue &#125;)</span><br><span class="line">    // 数据双向绑定</span><br><span class="line">    function valChange (e: string) &#123;</span><br><span class="line">      emit(&#x27;update:modelValue&#x27;, e)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      sea,</span><br><span class="line">      valChange</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>2、<strong>多个数据双向绑定</strong> - 与单数据绑定差别不大</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;ChildComp v-model=&quot;search&quot; v-model:address=&quot;addr&quot; /&gt;</span><br><span class="line">// 子组件对应为</span><br><span class="line">props: &#123;</span><br><span class="line">　　modelValue: &#123; // 父组件 v-model 没有指定参数名，则默认是 modelValue</span><br><span class="line">　　　　type: String,</span><br><span class="line">　　　　default: &#x27;&#x27;</span><br><span class="line">　　&#125;,</span><br><span class="line">　　address: &#123;  // 父组件 v-model 有指定参数名，则是指定参数名</span><br><span class="line">　　　　type: String,</span><br><span class="line">　　　　default: &#x27;&#x27;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;,</span><br><span class="line">// input初始化</span><br><span class="line">const sea = ref(props.modelValue)</span><br><span class="line">const add = ref(props.address)</span><br><span class="line"> </span><br><span class="line">// 如果父组件传过来的数据是异步获取的，需要进行监听</span><br><span class="line">watch(() =&gt; props.modelValue, () =&gt; &#123; sea.value = props.modelValue &#125;)</span><br><span class="line">watch(() =&gt; props.address, () =&gt; &#123; add.value = props.address &#125;)</span><br><span class="line"> </span><br><span class="line">// 数据双向绑定</span><br><span class="line">emit(&#x27;update:modelValue&#x27;, e)</span><br><span class="line">emit(&#x27;update:address&#x27;, e)</span><br></pre></td></tr></table></figure><p><strong>3、利用 computed 简化父子组件双向数据绑定</strong></p><p>　　上面是通过 ref 声明响应式数据，其实可以通过 computed 计算属性的 get &#x2F; set 去简化操作。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const props = defineProps(&#123;</span><br><span class="line">  modelValue: &#123;</span><br><span class="line">    type: Boolean,</span><br><span class="line">    default: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const emit = defineEmits([&#x27;update:modelValue&#x27;])</span><br><span class="line">const show = computed(&#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return props.modelValue</span><br><span class="line">  &#125;,</span><br><span class="line">  set(v) &#123;</span><br><span class="line">    emit(&#x27;update:modelValue&#x27;, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">浅析Vue3中如何通过vmodel实现父子组件的双向数据绑定及利用computed简化父子组件双向绑定</summary>
    
    
    
    <category term="Vue3" scheme="http://example.com/categories/Vue3/"/>
    
    
    <category term="-Vue3" scheme="http://example.com/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3.0为什么更快</title>
    <link href="http://example.com/2021/03/19/Vue3/Vue3.0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9B%B4%E5%BF%AB/"/>
    <id>http://example.com/2021/03/19/Vue3/Vue3.0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9B%B4%E5%BF%AB/</id>
    <published>2021-03-19T07:59:12.000Z</published>
    <updated>2022-08-10T02:08:40.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="diff-方法优化"><a href="#diff-方法优化" class="headerlink" title="diff 方法优化"></a>diff 方法优化</h3><ul><li><code>Vue2.x</code> 中的虚拟 dom 是进行全量的对比。</li><li><code>Vue3.0</code> 中新增了静态标记(PatchFlag):在与上次虚拟结点进行对比的时候，只对比 带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容化</li></ul><h3 id="hoistStatic-静态提升"><a href="#hoistStatic-静态提升" class="headerlink" title="hoistStatic 静态提升"></a>hoistStatic 静态提升</h3><ul><li><code>Vue2.x</code> : 无论元素是否参与更新，每次都会重新创建。</li><li><code>Vue3.0</code> : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用</li></ul><h3 id="cacheHandlers-事件侦听器缓存"><a href="#cacheHandlers-事件侦听器缓存" class="headerlink" title="cacheHandlers 事件侦听器缓存"></a>cacheHandlers 事件侦听器缓存</h3><blockquote><p>默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一 个函数，所以没有追踪变化，直接缓存起来复用即可</p></blockquote><h3 id="ssr-渲染"><a href="#ssr-渲染" class="headerlink" title="ssr 渲染"></a>ssr 渲染</h3><blockquote><p>当再有大量的静态内容的时候，会已字符串的形式纯在buffer里，就算有动态改变的内容，也可以用模板插值的方法，这样比虚拟DOM来的快一点</p></blockquote><blockquote><p>当静态内容大到一定量级的时候，会用_createStaticVNode方法在客户端去生成一个static，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染，也就是说不需要经过虚拟dom的过程。</p></blockquote><p>传统的SPA单一页面响应，即客户端渲染的模式</p><ul><li><p><code>Vue2.x</code> :Vue.js构建的应用程序，默认情况下是有一个html模板页，然后通过webpack打包生成一堆js、css等等资源文件。然后塞到index.html中</p><p>  用户输入url访问页面 -&gt; 先得到一个html模板页 -&gt; 然后通过异步请求服务端数据 -&gt; 得到服务端的数据 -&gt; 渲染成局部页面 -&gt; 用户</p><p>  这样一来，必然延长了首屏加载的时间</p></li><li><p><code>Vue3.x</code> :SSR（服务端渲染）可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p></li></ul><blockquote><p>简单点说：就是将页面在服务端渲染完成后在客户端直接显示。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面</p></blockquote>]]></content>
    
    
    <summary type="html">Vue3.0为什么更快</summary>
    
    
    
    <category term="Vue3" scheme="http://example.com/categories/Vue3/"/>
    
    
    <category term="-Vue3" scheme="http://example.com/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存</title>
    <link href="http://example.com/2021/03/03/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    <id>http://example.com/2021/03/03/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</id>
    <published>2021-03-03T07:12:27.000Z</published>
    <updated>2022-08-18T00:32:46.970Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下</p></blockquote><ul><li>先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；</li><li>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；<br>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。</li><li>当协商缓存也没命中时，服务器就会将资源发送回客户端。</li><li>当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li><li>当 f5刷新网页时，跳过强缓存，但是会检查协商缓存；</li></ul><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><ul><li>Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）</li><li>Cache-Control:max-age（该字段是 http1.1的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）</li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><ul><li>Last-Modified（值为资源最后更新时间，随服务器response返回）</li><li>If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）</li><li>ETag（表示资源内容的唯一标识，随服务器response返回）</li><li>If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</li></ul>]]></content>
    
    
    <summary type="html">什么是浏览器缓存</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="-前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Treeshaking详解</title>
    <link href="http://example.com/2020/11/27/Vue3/Treeshaking/"/>
    <id>http://example.com/2020/11/27/Vue3/Treeshaking/</id>
    <published>2020-11-27T05:53:19.000Z</published>
    <updated>2022-08-14T11:22:52.775Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是Threeshaking"><a href="#一、什么是Threeshaking" class="headerlink" title="一、什么是Threeshaking"></a>一、什么是Threeshaking</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tree shaking` 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 `Dead code elimination</span><br></pre></td></tr></table></figure><p>简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码</p><p>如果把代码打包比作制作蛋糕，传统的方式是把鸡蛋（带壳）全部丢进去搅拌，然后放入烤箱，最后把（没有用的）蛋壳全部挑选并剔除出去</p><p>而<code>treeshaking</code>则是一开始就把有用的蛋白蛋黄（import）放入搅拌，最后直接作出蛋糕</p><p>也就是说 ，<code>tree shaking</code> 其实是找出使用的代码</p><p>在<code>Vue2</code>中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是<code>Vue</code>实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>而<code>Vue3</code>源码引入<code>tree shaking</code>特性，将全局 API 进行分块。如果您不使用其某些功能，它们将不会包含在您的基础包中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick, observable &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="二、如何做"><a href="#二、如何做" class="headerlink" title="二、如何做"></a>二、如何做</h3><p><code>Tree shaking</code>是基于<code>ES6</code>模板语法（<code>import</code>与<code>exports</code>），主要是借助<code>ES6</code>模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量</p><p><code>Tree shaking</code>无非就是做了两件事：</p><ul><li>编译阶段利用<code>ES6 Module</code>判断哪些模块已经加载</li><li>判断那些模块和变量未被使用或者引用，进而删除对应代码</li></ul><p>下面就来举个例子：</p><p>通过脚手架<code>vue-cli</code>安装<code>Vue2</code>与<code>Vue3</code>项目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create vue-demo</span><br></pre></td></tr></table></figure><h4 id="Vue2-项目"><a href="#Vue2-项目" class="headerlink" title="Vue2 项目"></a>Vue2 项目</h4><p>组件中使用<code>data</code>属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data: () =&gt; (&#123;</span><br><span class="line">            count: 1,</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>对项目进行打包，体积如下图</p><p><img src="https://static.vue-js.com/6bd2aff0-6097-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><p>为组件设置其他属性（<code>compted</code>、<code>watch</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">question</span>:<span class="string">&quot;&quot;</span>, </span><br><span class="line">        <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="attr">double</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> * <span class="number">2</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">        <span class="attr">question</span>: <span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再一次打包，发现打包出来的体积并没有变化</p><p><img src="https://static.vue-js.com/7c29e260-6097-11eb-ab90-d9ae814b240d.png" alt="img"></p><h4 id="Vue3-项目"><a href="#Vue3-项目" class="headerlink" title="Vue3 项目"></a>Vue3 项目</h4><p>组件中简单使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, defineComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将项目进行打包</p><p><img src="https://static.vue-js.com/95df0000-6097-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><p>在组件中引入<code>computed</code>和<code>watch</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, defineComponent, computed, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> state.<span class="property">count</span>,</span><br><span class="line">      <span class="function">(<span class="params">count, preCount</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(preCount);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">      double,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再次对项目进行打包，可以看到在引入<code>computer</code>和<code>watch</code>之后，项目整体体积变大了</p><p><img src="https://static.vue-js.com/b36a7a00-6097-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><h2 id="三、作用"><a href="#三、作用" class="headerlink" title="三、作用"></a>三、作用</h2><p>通过<code>Tree shaking</code>，<code>Vue3</code>给我们带来的好处是：</p><ul><li>减少程序体积（更小）</li><li>减少程序执行时间（更快）</li><li>便于将来对程序架构进行优化（更友好）</li></ul>]]></content>
    
    
    <summary type="html">Treeshaking详解</summary>
    
    
    
    <category term="Treeshaking" scheme="http://example.com/categories/Treeshaking/"/>
    
    
    <category term="-Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="-Vue3" scheme="http://example.com/tags/Vue3/"/>
    
  </entry>
  
</feed>
